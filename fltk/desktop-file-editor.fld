# data file for the Fltk User Interface Designer (fluid)
version 1.0303 
i18n_type 1 
i18n_include <libintl.h> 
i18n_function gettext 
header_name {.h} 
code_name {.cxx}
decl {\#include <dirent.h>} {public local
} 

decl {\#include <iomanip>} {public global
} 

decl {\#include <string>} {public local
} 

decl {\#include <iostream>} {public local
} 

decl {\#include <fstream>} {public local
} 

decl {\#include <vector>} {public local
} 

decl {\#include <sys/stat.h>} {public local
} 

decl {\#include <sys/types.h>} {public local
} 

decl {\#include <algorithm>} {public local
} 

decl {\#include <float.h>} {public local
} 

decl {\#include "../include/fltkfunctions.hpp"} {public global
} 

decl {\#include <sstream>} {public local
} 

decl {\#include <FL/Fl_Text_Buffer.H>} {public global
} 

decl {\#include "../include/common.hpp"} {public global
} 

class Desktop {open
} {
  decl {Fl_Text_Buffer * textBuffer;} {public local
  }
  Function {make_window(std::string filePassedIn)} {open
  } {
    Fl_Window {} {
      label {Desktop File Editor} open selected
      xywh {217 115 415 570} type Double color 47
      code0 {load(filePassedIn);} xclass {desktop-file-editor} visible
    } {
      Fl_Scroll {} {open
        xywh {0 0 420 563}
      } {
        Fl_Tabs {} {open
          xywh {5 5 415 490} box FLAT_BOX color 47
        } {
          Fl_Group {} {
            label Normal open
            xywh {5 30 415 455} box FLAT_BOX selection_color 45
          } {
            Fl_Input name {
              label Name
              tooltip {Specific name of the application, for example "Mozilla".} xywh {145 50 255 30} box FLAT_BOX labelfont 1
            }
            Fl_Input comment {
              label Comment
              tooltip {Tooltip for the entry, for example "View sites on the Internet". The value should not be redundant with the values of Name and GenericName.} xywh {145 86 255 31} box FLAT_BOX
            }
            Fl_Input tryexec {
              label TryExec
              tooltip {Path to an executable file on disk used to determine if the program is actually installed. If the path is not an absolute path, the file is looked up in the $PATH environment variable. If the file is not present or if it is not executable, the entry may be ignored (not be used in menus, for example).} xywh {145 123 255 30} box FLAT_BOX
            }
            Fl_Input exec {
              label Exec
              tooltip {Program to execute, possibly with arguments. See the Exec key for details on how this key works. The Exec key is required if DBusActivatable is not set to true. Even if DBusActivatable is true, Exec should be specified for compatibility with implementations that do not understand DBusActivatable.} xywh {145 159 255 30} box FLAT_BOX
            }
            Fl_Input icon {
              label Icon
              tooltip {Icon to display in file manager, menus, etc. If the name is an absolute path, the given file will be used. If the name is not an absolute path, the algorithm described in the Icon Theme Specification will be used to locate the icon.} xywh {145 196 255 30} box FLAT_BOX
            }
            Fl_Input type {
              tooltip {This specification defines 3 types of desktop entries: Application (type 1), Link (type 2) and Directory (type 3). To allow the addition of new types in the future, implementations should ignore desktop entries with an unknown type} xywh {145 232 255 30} box FLAT_BOX
            }
            Fl_Input categories {
              tooltip {Categories in which the entry should be shown in a menu (for possible values see the Desktop Menu Specification).} xywh {145 269 255 30} box FLAT_BOX
            }
            Fl_Input notshowin {
              tooltip {A list of strings identifying the desktop environments that should display/not display a given desktop entry.

By default, a desktop file should be shown, unless an OnlyShowIn key is present, in which case, the default is for the file not to be shown.

If $XDG_CURRENT_DESKTOP is set then it contains a colon-separated list of strings. In order, each string is considered. If a matching entry is found in OnlyShowIn then the desktop file is shown. If an entry is found in NotShowIn then the desktop file is not shown. If none of the strings match then the default action is taken (as above).

The same desktop name may not appear in both OnlyShowIn and NotShowIn of a group.} xywh {145 305 255 30} box FLAT_BOX
            }
            Fl_Input onlyshowin {
              tooltip {A list of strings identifying the desktop environments that should display/not display a given desktop entry.

By default, a desktop file should be shown, unless an OnlyShowIn key is present, in which case, the default is for the file not to be shown.

If $XDG_CURRENT_DESKTOP is set then it contains a colon-separated list of strings. In order, each string is considered. If a matching entry is found in OnlyShowIn then the desktop file is shown. If an entry is found in NotShowIn then the desktop file is not shown. If none of the strings match then the default action is taken (as above).

The same desktop name may not appear in both OnlyShowIn and NotShowIn of a group.} xywh {145 342 255 30} box FLAT_BOX
            }
            Fl_Input terminal {
              tooltip {Whether the program runs in a terminal window.} xywh {145 378 255 30} box FLAT_BOX
            }
            Fl_Input nodisplay {
              tooltip {NoDisplay means "this application exists, but don't display it in the menus". This can be useful to e.g. associate this application with MIME types, so that it gets launched from a file manager (or other apps), without having a menu entry for it (there are tons of good reasons for this, including e.g. the netscape -remote, or kfmclient openURL kind of stuff).} xywh {145 415 255 30} box FLAT_BOX
            }
            Fl_Menu_Button {} {
              label Type open
              tooltip {This specification defines 3 types of desktop entries: Application (type 1), Link (type 2) and Directory (type 3). To allow the addition of new types in the future, implementations should ignore desktop entries with an unknown type.} xywh {15 232 120 30} box FLAT_BOX down_box FLAT_BOX color 23 selection_color 37 labelfont 1
            } {
              MenuItem {} {
                label Application
                callback {type->value("Application");
type->redraw();
check_type();}
                tooltip {An application} xywh {15 140 100 20}
              }
              MenuItem {} {
                label Link
                callback {type->value("Link");
type->redraw();
check_type();}
                tooltip {A URL Link} xywh {15 150 100 20}
              }
              MenuItem {} {
                label Directory
                callback {type->value("Directory");
type->redraw();
check_type();}
                tooltip {A Directory} xywh {15 160 100 20}
              }
              MenuItem {} {
                label OTHER
                callback {type->value("");
type->redraw();
check_type();}
                tooltip {Allowing the addition of new types in the future.} xywh {15 170 100 20}
              }
            }
            Fl_Menu_Button cat_Button {
              label Categories
              tooltip {Categories in which the entry should be shown in a menu (for possible values see the Desktop Menu Specification).} xywh {15 269 120 30} box FLAT_BOX down_box FLAT_BOX color 23 selection_color 37
            } {
              MenuItem {} {
                label AudioVideo
                callback {categories->value("AudioVideo");
categories->redraw();}
                tooltip {Application for presenting, creating, or processing multimedia (audio/video)} xywh {15 130 100 20}
              }
              MenuItem {} {
                label Development
                callback {categories->value("Development");
categories->redraw();}
                tooltip {An application for development} xywh {15 15 100 20}
              }
              MenuItem {} {
                label Education
                callback {categories->value("Education");
categories->redraw();}
                tooltip {Educational software} xywh {15 15 100 20}
              }
              MenuItem {} {
                label Game
                callback {categories->value("Game");
categories->redraw();}
                tooltip {A game} xywh {15 25 100 20}
              }
              MenuItem {} {
                label Graphics
                callback {categories->value("Graphics");
categories->redraw();}
                tooltip {Application for viewing, creating, or processing graphics} xywh {15 35 100 20}
              }
              MenuItem {} {
                label Network
                callback {categories->value("Network");
categories->redraw();}
                tooltip {Network application such as a web browser} xywh {15 45 100 20}
              }
              MenuItem {} {
                label Office
                callback {categories->value("Office");
categories->redraw();}
                tooltip {An office type application} xywh {15 55 100 20}
              }
              MenuItem {} {
                label Science
                callback {categories->value("Science");
categories->redraw();}
                tooltip {Scientific software} xywh {15 65 100 20}
              }
              MenuItem {} {
                label Settings
                callback {categories->value("Settings");
categories->redraw();}
                tooltip {Settings applications} xywh {15 75 100 20}
              }
              MenuItem {} {
                label System
                callback {categories->value("System");
categories->redraw();}
                tooltip {System application, "System Tools" such as say a log viewer or network monitor} xywh {15 85 100 20}
              }
              MenuItem {} {
                label Utility
                callback {categories->value("Utility");
categories->redraw();}
                tooltip {Small utility application, "Accessories"} xywh {15 95 100 20}
              }
            }
            Fl_Menu_Button nsi_Button {
              label NotShowIn
              tooltip {A list of strings identifying the desktop environments that should display/not display a given desktop entry.

By default, a desktop file should be shown, unless an OnlyShowIn key is present, in which case, the default is for the file not to be shown.

If $XDG_CURRENT_DESKTOP is set then it contains a colon-separated list of strings. In order, each string is considered. If a matching entry is found in OnlyShowIn then the desktop file is shown. If an entry is found in NotShowIn then the desktop file is not shown. If none of the strings match then the default action is taken (as above).

The same desktop name may not appear in both OnlyShowIn and NotShowIn of a group.} xywh {15 305 120 30} box FLAT_BOX down_box FLAT_BOX color 23 selection_color 37
            } {
              MenuItem {} {
                label ToriOS
                callback {NotShowIn("ToriOS");}
                tooltip {ToriOS Desktop} xywh {15 120 100 20}
              }
              MenuItem {} {
                label GNOME
                callback {NotShowIn("GNOME");}
                tooltip {GNOME Desktop} xywh {15 5 100 20}
              }
              MenuItem {} {
                label KDE
                callback {NotShowIn("KDE");}
                tooltip {KDE Desktop} xywh {15 5 100 20}
              }
              MenuItem {} {
                label LXDE
                callback {NotShowIn("LXDE");}
                tooltip {LXDE Desktop} xywh {15 15 100 20}
              }
              MenuItem {} {
                label MATE
                callback {NotShowIn("MATE");}
                tooltip {MATÉ Desktop} xywh {15 25 100 20}
              }
              MenuItem {} {
                label Razor
                callback {NotShowIn("Razor");}
                tooltip {Razor-qt Desktop} xywh {15 35 100 20}
              }
              MenuItem {} {
                label ROX
                callback {NotShowIn("ROX");}
                tooltip {ROX Desktop} xywh {15 45 100 20}
              }
              MenuItem {} {
                label TDE
                callback {NotShowIn("TDE");}
                tooltip {Trinity Desktop} xywh {15 55 100 20}
              }
              MenuItem {} {
                label Unity
                callback {NotShowIn("Unity");}
                tooltip {Unity Shell} xywh {15 65 100 20}
              }
              MenuItem {} {
                label XFCE
                callback {NotShowIn("XFCE");}
                tooltip {XFCE Desktop} xywh {15 75 100 20}
              }
              MenuItem {} {
                label EDE
                callback {NotShowIn("EDE");}
                tooltip {EDE Desktop} xywh {15 85 100 20}
              }
              MenuItem {} {
                label Cinnamon
                callback {NotShowIn("Cinnamon");}
                tooltip {Cinnamon Desktop} xywh {15 95 100 20}
              }
              MenuItem {} {
                label Old
                callback {NotShowIn("Old");}
                tooltip {Legacy menu systems} xywh {15 105 100 20}
              }
            }
            Fl_Menu_Button osi_Button {
              label OnlyShowIn
              tooltip {A list of strings identifying the desktop environments that should display/not display a given desktop entry.

By default, a desktop file should be shown, unless an OnlyShowIn key is present, in which case, the default is for the file not to be shown.

If $XDG_CURRENT_DESKTOP is set then it contains a colon-separated list of strings. In order, each string is considered. If a matching entry is found in OnlyShowIn then the desktop file is shown. If an entry is found in NotShowIn then the desktop file is not shown. If none of the strings match then the default action is taken (as above).

The same desktop name may not appear in both OnlyShowIn and NotShowIn of a group.} xywh {15 342 120 30} box FLAT_BOX down_box FLAT_BOX color 23 selection_color 37
            } {
              MenuItem {} {
                label ToriOS
                callback {OnlyShowIn("ToriOS");}
                tooltip {ToriOS Desktop} xywh {15 130 100 20}
              }
              MenuItem {} {
                label GNOME
                callback {OnlyShowIn("GNOME");}
                tooltip {GNOME Desktop} xywh {15 15 100 20}
              }
              MenuItem {} {
                label KDE
                callback {OnlyShowIn("KDE");}
                tooltip {KDE Desktop} xywh {15 15 100 20}
              }
              MenuItem {} {
                label LXDE
                callback {OnlyShowIn("LXDE");}
                tooltip {LXDE Desktop} xywh {15 25 100 20}
              }
              MenuItem {} {
                label MATE
                callback {OnlyShowIn("MATE");}
                tooltip {MATÉ Desktop} xywh {15 35 100 20}
              }
              MenuItem {} {
                label Razor
                callback {OnlyShowIn("Razor");}
                tooltip {Razor-qt Desktop} xywh {15 45 100 20}
              }
              MenuItem {} {
                label ROX
                callback {OnlyShowIn("ROX");}
                tooltip {ROX Desktop} xywh {15 55 100 20}
              }
              MenuItem {} {
                label TDE
                callback {OnlyShowIn("TDE");}
                tooltip {Trinity Desktop} xywh {15 65 100 20}
              }
              MenuItem {} {
                label Unity
                callback {OnlyShowIn("Unity");}
                tooltip {Unity Shell} xywh {15 75 100 20}
              }
              MenuItem {} {
                label XFCE
                callback {OnlyShowIn("XFCE");}
                tooltip {XFCE Desktop} xywh {15 85 100 20}
              }
              MenuItem {} {
                label EDE
                callback {OnlyShowIn("EDE");}
                tooltip {EDE Desktop} xywh {15 95 100 20}
              }
              MenuItem {} {
                label Cinnamon
                callback {OnlyShowIn("Cinnamon");}
                tooltip {Cinnamon Desktop} xywh {15 105 100 20}
              }
              MenuItem {} {
                label Old
                callback {OnlyShowIn("Old");}
                tooltip {Legacy menu systems} xywh {15 115 100 20}
              }
            }
            Fl_Menu_Button term_Button {
              label Terminal
              tooltip {Whether the program runs in a terminal window.} xywh {15 378 120 30} box FLAT_BOX down_box FLAT_BOX color 23 selection_color 37
            } {
              MenuItem {} {
                label True
                callback {terminal->value("True");
terminal->redraw();}
                tooltip {Program requires a Terminal} xywh {15 170 100 20}
              }
              MenuItem {} {
                label False
                callback {terminal->value("False");
terminal->redraw();}
                tooltip {Program does NOT require a Terminal} xywh {15 180 100 20}
              }
            }
            Fl_Menu_Button nod_Button {
              label NoDisplay
              tooltip {NoDisplay means "this application exists, but don't display it in the menus". This can be useful to e.g. associate this application with MIME types, so that it gets launched from a file manager (or other apps), without having a menu entry for it (there are tons of good reasons for this, including e.g. the netscape -remote, or kfmclient openURL kind of stuff).} xywh {15 415 120 30} box FLAT_BOX down_box FLAT_BOX color 23 selection_color 37
            } {
              MenuItem {} {
                label True
                callback {nodisplay->value("True");
nodisplay->redraw();}
                tooltip {This application exists, but DO NOT display it in the menus} xywh {160 160 100 20}
              }
              MenuItem {} {
                label False
                callback {nodisplay->value("False");
nodisplay->redraw();}
                tooltip {The default (Display the item in menus)} xywh {170 170 100 20}
              }
            }
            Fl_Button icon_display {
              label ICON
              callback {std::string iconFILE=choose_an_icon();
if(iconFILE.compare("")!=0){
  makeWidgetIcon(iconFILE,o,48);
  o->copy_label("");
  icon->value(iconFILE.c_str());
}}
              xywh {35 160 65 65} box FLAT_BOX color 23 labelfont 1 align 512
            }
          }
          Fl_Group {} {
            label Advanced open
            xywh {10 30 405 455} box FLAT_BOX selection_color 45 hide
          } {
            Fl_Input genericname {
              label GenericName
              tooltip {Generic name of the application, for example "Web Browser".} xywh {145 40 255 30} box FLAT_BOX
            }
            Fl_Input version {
              label Version
              tooltip {Version of the Desktop Entry Specification that the desktop entry conforms with. Entries that confirm with this version of the specification should use 1.0. Note that the version field is not required to be present.} xywh {145 77 255 30} box FLAT_BOX
            }
            Fl_Input path {
              label Path
              tooltip {If entry is of type Application, the working directory to run the program in.} xywh {145 115 255 30} box FLAT_BOX
            }
            Fl_Input mime {
              label MimeType
              tooltip {The MIME type(s) supported by this application.} xywh {145 153 255 30} box FLAT_BOX
            }
            Fl_Input implements {
              label Implements
              tooltip {A list of interfaces that this application implements. By default, a desktop file implements no interfaces. See http://standards.freedesktop.org/desktop-entry-spec/latest/ar01s08.html for more information on how this works.} xywh {145 190 255 30} box FLAT_BOX
            }
            Fl_Input keywords {
              label Keywords
              tooltip {A list of strings which may be used in addition to other metadata to describe this entry. This can be useful e.g. to facilitate searching through entries. The values are not meant for display, and should not be redundant with the values of Name or GenericName.} xywh {145 228 255 30} box FLAT_BOX
            }
            Fl_Input wmclass {
              label StartupWMClass
              tooltip {If specified, it is known that the application will map at least one window with the given string as its WM class or WM name hint (see the Startup Notification Protocol Specification for more details).} xywh {145 266 255 30} box FLAT_BOX
            }
            Fl_Input url {
              label URL
              tooltip {If entry is Link type, the URL to access.} xywh {145 304 255 30} box FLAT_BOX labelfont 1
            }
            Fl_Input actions {
              tooltip {Identifiers for application actions. This can be used to tell the application to make a specific action, different from the default behavior. The Application actions section describes how actions work.} xywh {145 341 255 30} box FLAT_BOX deactivate
            }
            Fl_Input notify {
              tooltip {If true, it is KNOWN that the application will send a "remove" message when started with the DESKTOP_STARTUP_ID environment variable set. If false, it is KNOWN that the application does not work with startup notification at all (does not shown any window, breaks even when using StartupWMClass, etc.). If absent, a reasonable handling is up to implementations (assuming false, using StartupWMClass, etc.). (See the Startup Notification Protocol Specification for more details).} xywh {145 379 255 30} box FLAT_BOX
            }
            Fl_Input hidden {
              tooltip {Hidden should have been called Deleted. It means the user deleted (at his level) something that was present (at an upper level, e.g. in the system dirs). It's strictly equivalent to the .desktop file not existing at all, as far as that user is concerned. This can also be used to "uninstall" existing files (e.g. due to a renaming) - by letting make install install a file with Hidden=true in it.} xywh {145 417 255 30} box FLAT_BOX
            }
            Fl_Input dbus {
              tooltip {A boolean value specifying if D-Bus activation is supported for this application. If this key is missing, the default value is false. If the value is true then implementations should ignore the Exec key and send a D-Bus message to launch the application. See D-Bus Activation for more information on how this works. Applications should still include Exec= lines in their desktop files for compatibility with implementations that do not understand the DBusActivatable key.} xywh {145 455 255 30} box FLAT_BOX
            }
            Fl_Button {} {
              label Actions
              tooltip {Identifiers for application actions. This can be used to tell the application to make a specific action, different from the default behavior. The Application actions section describes how actions work.} xywh {10 341 130 30} box FLAT_BOX color 23 deactivate
            }
            Fl_Menu_Button notify_Button {
              label StartupNotify
              tooltip {If true, it is KNOWN that the application will send a "remove" message when started with the DESKTOP_STARTUP_ID environment variable set. If false, it is KNOWN that the application does not work with startup notification at all (does not shown any window, breaks even when using StartupWMClass, etc.). If absent, a reasonable handling is up to implementations (assuming false, using StartupWMClass, etc.). (See the Startup Notification Protocol Specification for more details).} xywh {10 379 130 30} box FLAT_BOX down_box FLAT_BOX color 23 selection_color 37
            } {
              MenuItem {} {
                label True
                callback {notify->value("True");
notify->redraw();}
                tooltip {It is KNOWN that the application will send a "remove" message when started with the DESKTOP_STARTUP_ID environment variable set.} xywh {20 150 100 20}
              }
              MenuItem {} {
                label False
                callback {notify->value("False");
notify->redraw();}
                tooltip {It is KNOWN that the application does not work with startup notification at all (does not shown any window, breaks even when using StartupWMClass, etc.)} xywh {20 160 100 20}
              }
            }
            Fl_Menu_Button {} {
              label Hidden
              tooltip {Hidden should have been called Deleted. It means the user deleted (at his level) something that was present (at an upper level, e.g. in the system dirs). It's strictly equivalent to the .desktop file not existing at all, as far as that user is concerned. This can also be used to "uninstall" existing files (e.g. due to a renaming) - by letting make install install a file with Hidden=true in it.} xywh {10 417 130 30} box FLAT_BOX down_box FLAT_BOX color 23 selection_color 37
            } {
              MenuItem {} {
                label True
                callback {hidden->value("True");
hidden->redraw();}
                tooltip {It means the user deleted (at his level) something that was present (at an upper level, e.g. in the system dirs). It's strictly equivalent to the .desktop file not existing at all, as far as that user is concerned.} xywh {20 160 100 20}
              }
              MenuItem {} {
                label False
                callback {hidden->value("False");
hidden->redraw();}
                tooltip {The default is not to hide this} xywh {20 170 100 20}
              }
            }
            Fl_Menu_Button {} {
              label DBusActivatable
              tooltip {A boolean value specifying if D-Bus activation is supported for this application. If this key is missing, the default value is false. If the value is true then implementations should ignore the Exec key and send a D-Bus message to launch the application. See D-Bus Activation for more information on how this works. Applications should still include Exec= lines in their desktop files for compatibility with implementations that do not understand the DBusActivatable key.} xywh {10 455 130 30} box FLAT_BOX down_box FLAT_BOX color 23 selection_color 37
            } {
              MenuItem {} {
                label True
                callback {dbus->value("True");
dbus->redraw();}
                tooltip {Implementations should ignore the Exec key and send a D-Bus message to launch the application. See D-Bus Activation for more information on how this works.} xywh {170 170 100 20}
              }
              MenuItem {} {
                label False
                callback {dbus->value("False");
dbus->redraw();}
                tooltip {The default is to assume D-Bus activation is not supported} xywh {180 180 100 20}
              }
            }
          }
        }
        Fl_Button {} {
          label OPEN
          callback {open_file();}
          tooltip {Open a desktop file} xywh {15 533 80 30} box FLAT_BOX color 23
        }
        Fl_Button {} {
          label SAVE
          callback {save_file();}
          tooltip {Save the current data as a file} xywh {320 533 80 30} box FLAT_BOX color 61 labelcolor 7
        }
        Fl_Input Filename {
          tooltip {The file you want to save (or the name of the current open file)} xywh {115 500 285 30} box FLAT_BOX
        }
        Fl_Button {} {
          label CLEAR
          callback {clear_all();}
          tooltip {CLEAR EVERYTHING} xywh {220 533 80 30} box FLAT_BOX color 80 labelcolor 7
        }
        Fl_Button {} {
          label PREVIEW
          callback {std::string re=stringfile();
if(re.compare("")!=0){
  preview_window(re)->show();
}}
          tooltip {Preview text} xywh {115 533 80 30} box FLAT_BOX color 95 labelcolor 32
        }
        Fl_Button {} {
          label {File Name}
          callback {std::string filename=choose_a_directory_to_save("","");
if(filename.compare("")!=0){Filename->value();}}
          tooltip {Open a desktop file} xywh {15 498 80 30} box FLAT_BOX color 23
        }
      }
    }
  }
  Function {preview_window(std::string message)} {} {
    Fl_Window preview_win {
      label Preview open
      xywh {70 194 465 465} type Double hide
    } {
      Fl_Scroll {} {open
        xywh {10 5 440 410}
      } {
        Fl_Text_Display {} {
          xywh {10 5 440 410} box FLAT_BOX
          code0 {//if(message.compare("")!=0)o->insert(message.c_str());}
        }
        Fl_Box {} {
          xywh {10 5 440 410} align 21
          code0 {if(message.compare("")!=0)o->copy_label(message.c_str());}
        }
      }
      Fl_Button {} {
        label SAVE
        callback {save_file();
preview_win->hide();}
        tooltip {Save the current data as a file} xywh {365 425 80 30} box FLAT_BOX color 61 labelcolor 7
      }
      Fl_Button {} {
        label CLOSE
        callback {preview_win->hide();}
        tooltip {CLEAR EVERYTHING} xywh {275 425 80 30} box FLAT_BOX color 80 labelcolor 7
      }
    }
  }
  Function {activate(Fl_Input* o)} {} {
    code {o->activate();
o->color(FL_WHITE);} {}
  }
  Function {activate(Fl_Menu_Button* o)} {} {
    code {o->activate();} {}
  }
  Function {check_type()} {} {
    code {if(isEmpty(type)){show_all();return;}
activate(type);
std::string TYPE=type->value();
if(TYPE.compare("Application")==0){
  show_apps_only();
}
else if(TYPE.compare("Directory")==0){
  show_dir_only();
}
else if(TYPE.compare("Link")==0){
  show_link_only();
}
else{
  show_all();
}} {}
  }
  Function {choose_directory()} {return_type {std::string}
  } {
    code {std::string message=gettext("Choose a Directory");
const char* fname=getenv("PWD");
if (fname == NULL){
  fname=getenv("XDG_CONFIG_HOME");
  if (fname == NULL){fname=getenv("HOME");}
  else{
    std::string autostart=fname;
    autostart+="/autostart/";
    fname=autostart.c_str();
  }
}
std::string RESULT=choose_a_directory(fname,message);
return RESULT;} {}
  }
  Function {clear_all()} {} {
    code {//normal
clear_input(name);
clear_input(exec);
clear_input(tryexec);
clear_input(comment);
clear_input(icon);
clear_input(type);
clear_input(categories);
clear_input(notshowin);
clear_input(onlyshowin);
clear_input(terminal);
clear_input(nodisplay);
//advanced
clear_input(genericname);
clear_input(version);
clear_input(path);
clear_input(mime);
clear_input(implements);
clear_input(keywords);
clear_input(wmclass);
clear_input(url);
clear_input(actions);
clear_input(notify);
clear_input(hidden);
clear_input(dbus);
clear_input(Filename);
show_all();} {}
  }
  Function {clear_input(Fl_Input *o)} {} {
    code {o->value("");
o->redraw();} {}
  }
  Function {close()} {} {}
  Function {DEactivate(Fl_Input* o)} {} {
    code {o->deactivate();
o->color(FL_LIGHT2);
o->value("");} {}
  }
  Function {DEactivate(Fl_Menu_Button* o)} {} {
    code {o->deactivate();} {}
  }
  Function {get_line(std::string filename, std::string line)} {return_type {std::string}
  } {
    code {std::string thisLine = linuxcommon::get_line_with_equal(filename,line);
return thisLine;} {}
  }
  Function {isEmpty(Fl_Input *o)} {return_type bool
  } {
    code {const char* charVal= o->value();
if ( charVal == NULL){
  make_red(o);
  return true;
}
std::string STRINGval=o->value();
if (STRINGval.compare("")==0){
  make_red(o);
  return true;
}
make_white(o);
return false;} {}
  }
  Function {keyWords(std::string filename)} {return_type {std::string}
  } {
    code {std::string GenericName = get_line("GenericName=",filename);
std::string Keywords = get_line("Keywords=",filename);
std::string result;
if(GenericName.compare("")!=0){result=GenericName;}
if(Keywords.compare("")!=0){result+=Keywords;}
if(result.compare("")==0){result="none";}
return result;} {}
  }
  Function {load(std::string result)} {} {
    code {if(result.compare("")!=0){
  std::string tmp=result;
  if(result.find("../")<result.length()){
    std::string pwd=linuxcommon::current_directory();
    if(pwd.compare("")!=0){
      unsigned int finder = result.rfind("../");
      if(finder<result.length()){
        tmp=tmp.substr(finder+3,std::string::npos);
        tmp=pwd+tmp;
      }
    }
  }
  std::cout<<result<<std::endl;
  populate(result);
  Filename->value(tmp.c_str());
}
check_type();} {}
  }
  Function {make_red(Fl_Input *o)} {} {
    code {o->color(FL_RED);
o->redraw();} {}
  }
  Function {make_white(Fl_Input *o)} {} {
    code {o->color(FL_WHITE);
o->redraw();} {}
  }
  Function {not_showin(std::string filename)} {return_type bool
  } {
    code {char* desktop = getenv("XDG_CURRENT_DESKTOP");
char* desktop_session = getenv("DESKTOP_SESSION");
std::string result = get_line("NotShowIn=",filename);
unsigned int found = 0;
if(result.compare("")==0){
  return false;
}
std::transform(result.begin(),result.end(),result.begin(),::tolower);
std::string temp1,temp2;
temp2=result;
for(unsigned int i = 0; i<result.length();i++){
  found = temp2.find_first_of(';');
  if(found < temp2.length()){
    temp2=temp2.erase(found,temp2.length());
    temp1 = result.erase(0,found+1);
  if (desktop !=NULL){
    //std::cout<<"desktop: "<<desktop<<"\\nresult: "<<temp2<<std::endl;
    if (temp2.compare(desktop)==0){
    return true;
    }
  }
  if (desktop_session !=NULL){
    //std::cout<<"desktop session: "<<desktop_session<<"\\nresult: "<<temp2<<std::endl;
    if (temp2.compare(desktop_session)==0){
    return true;
    }
  }
    temp2=temp1;
  }
}
return false;} {}
  }
  Function {name_line(std::string filename)} {return_type {std::string}
  } {
    code {std::string base_lang,result,strlang,strlanguage,startbase,NAME,LOCALNAME,LOCALEND;
NAME="Name";
LOCALNAME="Name[";
LOCALEND="]=";
unsigned int underscore = 0;
char* lang = getenv("LANG");
char* language = getenv("LANGUAGE");
if(lang!=NULL)strlang = lang;
if(language!=NULL)strlanguage =language;
if (strlanguage.compare("")!=0){  
  result=get_line(filename, (LOCALNAME+ strlanguage + LOCALEND));
  if(result.compare("")!=0){return result;}
  base_lang=strlanguage;
}
else{
  if (strlang.compare("")!=0){
      unsigned int dot = 0;
      dot=strlang.find('.');
      if(dot<strlang.length())
        startbase=strlang.erase(dot,strlang.length());
      result=get_line(filename, (LOCALNAME+ startbase + LOCALEND));
      if(result.compare("")!=0){return result;}
      base_lang=startbase;
   }
   else{return get_line(filename,"Name=");}
}
underscore=base_lang.find('_');
if(underscore<base_lang.length())
  base_lang=base_lang.erase(underscore,base_lang.length());
result=get_line( filename,(LOCALNAME+ base_lang + LOCALEND));
if(result.compare("")!=0){return result;}
return get_line(filename,"Name=");} {}
  }
  Function {no_display(std::string filename)} {return_type bool
  } {
    code {std::string result = get_line(filename,"NoDisplay=");
if(result.compare("")==0){
  return false;
}
std::transform(result.begin(),result.end(),result.begin(),::tolower);
if (result.compare("true")==0){return true;}
else{return false;}

return false;} {}
  }
  Function {NotShowIn(const char* DE)} {} {
    code {if(DE==NULL){return;}
if(!isEmpty(onlyshowin)){
  std::string ONLY = onlyshowin->value();
  unsigned int finder = 0;
  finder=ONLY.find(DE);
  if(finder<ONLY.length()){
    make_red(onlyshowin);
    make_red(notshowin);
    return;
  }
}
notshowin->value(DE);
notshowin->redraw();} {}
  }
  Function {only_show(std::string filename)} {return_type bool
  } {
    code {char* desktop = getenv("XDG_CURRENT_DESKTOP");
char* desktop_session = getenv("DESKTOP_SESSION");
std::string result = get_line("OnlyShowIn=",filename);
unsigned int found = 0;
if(result.compare("")==0){
//Only show in line doesn't exist
  return true;
}
//std::cout<<"OnlyShowIn="<<result<<std::endl;
//compare lower case words only
std::transform(result.begin(),result.end(),result.begin(),::tolower);

std::string temp1,temp2;
temp2=result;

for(unsigned int i = 0; i<result.length();i++){
  found = temp2.find_first_of(';');
  if(found < temp2.length()){
    temp2=temp2.erase(found,temp2.length());
    temp1 = result.erase(0,found+1);
    if (desktop !=NULL){
      //std::cout<<"desktop: "<<desktop<<"\\nresult: "<<temp2<<std::endl;
      if (temp2.compare(desktop)==0){return true;}
    }
    if (desktop_session !=NULL){
     // std::cout<<"desktop session: "<<desktop_session<<"\\nresult: "<<temp2<<std::endl;
      if(temp2.compare(desktop_session)==0){return true;}
    }
    if (temp2.compare("unity")==0){return true;}
    temp2=temp1;
   }
   else{
     
   }
}
return false;} {}
  }
  Function {OnlyShowIn(const char* DE)} {} {
    code {if(DE==NULL){return;}
if(!isEmpty(notshowin)){
  std::string ONLY = notshowin->value();
  unsigned int finder = 0;
  finder=ONLY.find(DE);
  if(finder<ONLY.length()){
    make_red(onlyshowin);
    make_red(notshowin);
    return;
  }
}
onlyshowin->value(DE);
onlyshowin->redraw();} {}
  }
  Function {open_file()} {} {
    code {std::string message=gettext("Choose a Desktop File");
std::string pat="*.desktop";
const char* filer = Filename->value();
std::string fname="desktop-file-editor.desktop";
if(filer!=NULL){fname=filer;}
std::string result =nativeFileDialog(message,fname,pat);
load(result);} {}
  }
  Function {populate(std::string fileName)} {open
  } {
    code {//if(!linuxcommon::test_file(fileName)){return;}
if(fileName.compare("")==0){return;}
std::string filename=fileName; 
std::string NAME,EXEC,CATS,TYPE,ICON,COMMENT,ONLY,NOT,URL,WMCLASS,KEYWORDS,IMPLEMENTS,VERSION,ENCODING,PATH,MIME,TRY,GENERIC,NODISPLAY,TERMINAL,STARTUPNOTIFY,HIDDEN,DBUS;

TYPE=get_line(filename,"Type=");
VERSION=get_line(filename,"Version=");
NAME=name_line(filename);
GENERIC=get_line(filename,"GenericName=");

COMMENT=get_line(filename,"Comment=");
ICON=get_line(filename,"Icon=");
if(ICON.compare("")!=0){
  icon_display->copy_label("");
  makeWidgetIcon(ICON,icon_display,48);
}
ONLY=get_line(filename,"OnlyShowIn=");
NOT=get_line(filename,"NotShowIn=");
TRY=get_line(filename,"TryExec=");
EXEC=get_line(filename,"Exec=");
PATH=get_line(filename,"Path=");
//Actions....
MIME=get_line(filename,"MimeType");
CATS=get_line(filename,"Categories=");
IMPLEMENTS=get_line(filename,"Implements=");
KEYWORDS=get_line(filename,"Keywords=");
WMCLASS=get_line(filename,"StartupWMClass=");
URL=get_line(filename,"URL=");
MIME=get_line(filename,"MimeType");
STARTUPNOTIFY=get_line(filename,"StatupNotify=");
TERMINAL=get_line(filename,"Terminal=");
NODISPLAY=get_line(filename,"NoDisplay=");
DBUS=get_line(filename,"DBusActivatable=");
HIDDEN=get_line(filename,"Hidden=");
//extras
ENCODING=get_line(filename,"Encoding=");
//Setup
set_input(name,NAME);
set_input(genericname,GENERIC);
set_input(exec,EXEC);
set_input(comment,COMMENT);
set_input(icon,ICON);
set_input(tryexec,TRY);
set_input(categories,CATS);
set_input(onlyshowin,ONLY);
set_input(type,TYPE);
set_input(version,VERSION);
set_input(path,PATH);
set_input(implements,IMPLEMENTS);
set_input(keywords,KEYWORDS);
set_input(wmclass,WMCLASS);
set_input(url,URL);
set_input(mime,MIME);
set_input(notify,STARTUPNOTIFY);
set_input(nodisplay,NODISPLAY);
set_input(terminal,TERMINAL);
set_input(hidden,HIDDEN);
set_input(dbus,DBUS);
check_type();} {}
  }
  Function {save_file()} {} {
    code {std::string testFilename;
const char* filer = Filename->value();
if (isEmpty(Filename)){
  make_red(Filename);
  return;
}
testFilename=filer;
unsigned int found = 0;
found=testFilename.find(".desktop");
if (found > testFilename.length()){
  make_red(Filename);
  testFilename += ".desktop";
}
found = 0;
found= testFilename.find("/");
if(found>testFilename.length()){
  std::string choice=choose_directory();
  if(choice.compare("")==0){
    make_red(Filename);
    return;
  }
  choice+="/";
  choice+=testFilename;
  testFilename=choice;
}
Filename->value(testFilename.c_str());
Filename->redraw();
write_out();

//clear_all();} {}
  }
  Function {set_input(Fl_Input *o, std::string val)} {} {
    code {make_white(o);
o->value(val.c_str());
o->redraw();} {}
  }
  Function {show_all()} {} {
    code {activate(tryexec);
activate(exec);
activate(path);
activate(terminal);
activate(actions);
activate(categories);
activate(keywords);
activate(notify);
activate(wmclass);
activate(mime);
activate(url);
activate(cat_Button);
activate(notify_Button);
activate(term_Button);} {}
  }
  Function {show_apps_only()} {} {
    code {activate(tryexec);
activate(exec);
activate(path);
activate(terminal);
activate(actions);
activate(categories);
activate(keywords);
activate(notify);
activate(wmclass);
activate(mime);
activate(cat_Button);
activate(notify_Button);
activate(term_Button);
DEactivate(url);} {}
  }
  Function {show_dir_only()} {} {
    code {DEactivate(tryexec);
DEactivate(exec);
DEactivate(path);
DEactivate(terminal);
DEactivate(term_Button);
DEactivate(actions);
DEactivate(categories);
DEactivate(cat_Button);
DEactivate(keywords);
DEactivate(notify);
DEactivate(notify_Button);
DEactivate(wmclass);
DEactivate(mime);
DEactivate(url);} {}
  }
  Function {show_link_only()} {} {
    code {DEactivate(tryexec);
DEactivate(exec);
DEactivate(path);
DEactivate(terminal);
DEactivate(term_Button);
DEactivate(actions);
DEactivate(categories);
DEactivate(cat_Button);
DEactivate(keywords);
DEactivate(notify);
DEactivate(notify_Button);
DEactivate(wmclass);
DEactivate(mime);
activate(url);} {}
  }
  Function {stringfile()} {return_type {std::string}
  } {
    code {const char* FILENAME=Filename->value();
if(FILENAME==NULL){std::cerr<<"Filename is NULL"<<std::endl;}
if(isEmpty(Filename)){
  make_red(Filename);
  return "";
}
else{make_white(Filename);}
const char* NAME = name->value();
if(NAME==NULL){std::cerr<<"Name is NULL"<<std::endl;}
if(isEmpty(name)){
  make_red(name);
  return "";
}
else{make_white(name);}
const char* TYPE = type->value();
if(TYPE==NULL){std::cerr<<"Type is NULL"<<std::endl;}
if (isEmpty(type)){
  make_red(type);
  return "";
}
else{make_white(type);}
std::string TypeOf=type->value(); 
std::string fileContents="[Desktop Entry]\\n";
fileContents+=testValue("Type=",type);
fileContents+=testValue("Version=",version);
fileContents+=testValue("Name=",name);
fileContents+=testValue("GenericName=",genericname);
if (TypeOf.compare("Application")==0){
  const char* EXEC = exec->value();
  if(EXEC==NULL){std::cerr<<"Executable is NULL"<<std::endl;}
  if (isEmpty(exec)){
    make_red(exec);
    return "";
  }
  fileContents+=testValue("Exec=",exec);
  fileContents+=testValue("TryExec=",tryexec);
  fileContents+=testValue("Terminal=", terminal);
  fileContents+=testValue("Categories=",categories);
  fileContents+=testValue("Path=",path);
  fileContents+=testValue("MimeType=",mime);
  fileContents+=testValue("Keywords=",keywords);
  fileContents+=testValue("StartUpWMClass=",wmclass);
  fileContents+=testValue("StartupNotify=",notify);
}
fileContents+=testValue("Comment=",comment);
fileContents+=testValue("Icon=",icon);
fileContents+=testValue("NoDisplay=",nodisplay);
fileContents+=testValue("Hidden=", hidden);
fileContents+=testValue("DBusActivatable=",dbus);
fileContents+=testValue("Implements=",implements);

//TODO test OnlyShowIn and NotShowIn to not have the same values ever
fileContents+=testValue("NotShowIn=",notshowin);
fileContents+=testValue("OnlyShowIn=",onlyshowin);

if (TypeOf.compare("Link")==0){
  std::string linktext=testValue("URL=",url);
  if(linktext.compare("")==0){
    make_red(url);
    return "";
  }
  fileContents+=linktext;
}
  
return fileContents;} {}
  }
  Function {termie_out(std::string terminal_Command_You_Want_Output_From)} {return_type {std::string}
  } {
    code {return linuxcommon::term_out(terminal_Command_You_Want_Output_From);} {}
  }
  Function {testValue(std::string TEXT, Fl_Input* o)} {return_type {std::string}
  } {
    code {std::string fileContents;
const char* tempval=o->value();
if (tempval==NULL){return "";}
std::string TEMPval=o->value();
if(TEMPval.compare("")==0){return "";}
fileContents+=TEXT;
fileContents+=TEMPval;
fileContents+="\\n";
return fileContents;} {}
  }
  Function {write_out()} {} {
    code {const char* FILENAME=Filename->value();
std::string fileContents=stringfile();
preview_window(fileContents)->show();
if(!linuxcommon::save_string_to_file(fileContents,FILENAME)){
  linuxcommon::echo_error("Did not save the file correctly");
}} {}
  }
} 

Function {main(int argc, char *argv[])} {return_type int
} {
  code {std::string command;
try{
  //integers for searching the argv
  if(argc>0){
    for(int i=1;i<argc;++i){
      command=argv[i];
      for(int i=0;i<argc;i++){
        if(linuxcommon::test_file(command)){
          Desktop D;
          D.make_window(command)->show();
          return Fl::run();
        }
      }
    }
  }
  Desktop D;
  D.make_window("")->show();
  return Fl::run();
}
catch (const std::exception& e){
  std::cerr << "Unhandled exception:\\n" << e.what() << std::endl;
  return EXIT_FAILURE;
}
catch (...){
  std::cerr << "Unknown exception!" << std::endl;
  return EXIT_FAILURE;
}} {}
} 
