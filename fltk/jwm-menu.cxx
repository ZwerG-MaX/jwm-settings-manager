/*                 Joe's Window Manager Configuration
 *
 * This program configures JWM using tinyxml2 and FLTK
 *
 *         Copyright (C) 2014  Israel <israel@torios.org>
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * This has been developed as a part of the ToriOS Project
 * This has been developed by Israel<israel@torios.org>
 *
 *
 * You may redistribute this, but you must keep this comment in place
 * Jesus is my Lord, and if you don't like it feel free to ignore it.
 */
// generated by Fast Light User Interface Designer (fluid) version 1.0302

#include <libintl.h>
#include "jwm-menu.h"

void MenuUI::cb_Configure_i(Fl_Button*, void*) {
  edit_an_item();
}
void MenuUI::cb_Configure(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->parent()->user_data()))->cb_Configure_i(o,v);
}

void MenuUI::cb_Cancel_i(Fl_Button*, void*) {
  cancel(menu_window);
UI ux;
ux.showSettings();
}
void MenuUI::cb_Cancel(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->parent()->user_data()))->cb_Cancel_i(o,v);
}

void MenuUI::cb_save_button_i(Fl_Button*, void*) {
  saveJWMRC(menu_window);
UI ux;
ux.showSettings();
}
void MenuUI::cb_save_button(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->parent()->user_data()))->cb_save_button_i(o,v);
}

void MenuUI::cb_Item_i(Fl_Button*, void*) {
  add_an_item();
}
void MenuUI::cb_Item(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->parent()->user_data()))->cb_Item_i(o,v);
}

void MenuUI::cb_menuElement_i(Fl_Browser* o, void*) {
  int linenum = o->value();
menuElementText->select(linenum);
}
void MenuUI::cb_menuElement(Fl_Browser* o, void* v) {
  ((MenuUI*)(o->parent()->parent()->user_data()))->cb_menuElement_i(o,v);
}

void MenuUI::cb_Item1_i(Fl_Button*, void*) {
  remove_an_item();
}
void MenuUI::cb_Item1(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->parent()->user_data()))->cb_Item1_i(o,v);
}

#include <FL/Fl_Bitmap.H>
static unsigned char idata_minus[] =
{0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,
0,0,0};
static Fl_Bitmap image_minus(idata_minus, 16, 16);

void MenuUI::cb_menuElementText_i(Fl_Browser* o, void*) {
  int linenum = o->value();
menuElement->select(linenum);
}
void MenuUI::cb_menuElementText(Fl_Browser* o, void* v) {
  ((MenuUI*)(o->parent()->parent()->user_data()))->cb_menuElementText_i(o,v);
}

void MenuUI::cb_root_menu_i(Fl_Browser* o, void*) {
  int line = o->value();
const char* menu = o->text(line);
choose_menu(menu);
}
void MenuUI::cb_root_menu(Fl_Browser* o, void* v) {
  ((MenuUI*)(o->parent()->parent()->user_data()))->cb_root_menu_i(o,v);
}

void MenuUI::cb_Menu_i(Fl_Button*, void*) {
  add_a_menu()->show();
}
void MenuUI::cb_Menu(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->parent()->user_data()))->cb_Menu_i(o,v);
}

void MenuUI::cb_Menu1_i(Fl_Button*, void*) {
  remove_a_menu();
}
void MenuUI::cb_Menu1(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->parent()->user_data()))->cb_Menu1_i(o,v);
}

void MenuUI::cb_add_prog_button_i(Fl_Button*, void*) {
  Apps apps;apps.loadTemp();
const char *f = "/usr/bin";
const char *m = "Choose a Program";
const char *p = "*";
int r = 0;
char *result = fl_file_chooser(m,p,f,r);
if(result!=NULL){
	add_input->value(result);
};
}
void MenuUI::cb_add_prog_button(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_add_prog_button_i(o,v);
}

void MenuUI::cb_OK_i(Fl_Button*, void*) {
  save_cb();
}
void MenuUI::cb_OK(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_OK_i(o,v);
}

void MenuUI::cb_add_icon_button_i(Fl_Button*, void*) {
  Apps apps;apps.loadTemp();
const char *f = "/usr/share/pixmaps";
const char *m = "Choose an Icon";
const char *p = "*.{xbm,XBM,xpm,XPM,png,PNG,svg,SVG}";
int r = 0;
char *result = fl_file_chooser(m,p,f,r);
if(result!=NULL){
	add_icon->value(result);
};
}
void MenuUI::cb_add_icon_button(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_add_icon_button_i(o,v);
}

void MenuUI::cb_Program_i(Fl_Menu_*, void*) {
  add_cb(0);
}
void MenuUI::cb_Program(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Program_i(o,v);
}

void MenuUI::cb_Restart_i(Fl_Menu_*, void*) {
  add_cb(1);
}
void MenuUI::cb_Restart(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Restart_i(o,v);
}

void MenuUI::cb_Exit_i(Fl_Menu_*, void*) {
  add_cb(2);
}
void MenuUI::cb_Exit(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Exit_i(o,v);
}

void MenuUI::cb_Separator_i(Fl_Menu_*, void*) {
  add_cb(3);
}
void MenuUI::cb_Separator(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Separator_i(o,v);
}

void MenuUI::cb_Include_i(Fl_Menu_*, void*) {
  add_cb(4);
}
void MenuUI::cb_Include(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Include_i(o,v);
}

void MenuUI::cb_Desktops_i(Fl_Menu_*, void*) {
  add_cb(5);
}
void MenuUI::cb_Desktops(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Desktops_i(o,v);
}

void MenuUI::cb_SendTo_i(Fl_Menu_*, void*) {
  add_cb(6);
}
void MenuUI::cb_SendTo(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_SendTo_i(o,v);
}

void MenuUI::cb_Stick_i(Fl_Menu_*, void*) {
  add_cb(7);
}
void MenuUI::cb_Stick(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Stick_i(o,v);
}

void MenuUI::cb_Maximize_i(Fl_Menu_*, void*) {
  add_cb(8);
}
void MenuUI::cb_Maximize(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Maximize_i(o,v);
}

void MenuUI::cb_Minimize_i(Fl_Menu_*, void*) {
  add_cb(9);
}
void MenuUI::cb_Minimize(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Minimize_i(o,v);
}

void MenuUI::cb_Shade_i(Fl_Menu_*, void*) {
  add_cb(10);
}
void MenuUI::cb_Shade(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Shade_i(o,v);
}

void MenuUI::cb_Move_i(Fl_Menu_*, void*) {
  add_cb(11);
}
void MenuUI::cb_Move(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Move_i(o,v);
}

void MenuUI::cb_Resize_i(Fl_Menu_*, void*) {
  add_cb(12);
}
void MenuUI::cb_Resize(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Resize_i(o,v);
}

void MenuUI::cb_Kill_i(Fl_Menu_*, void*) {
  add_cb(13);
}
void MenuUI::cb_Kill(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Kill_i(o,v);
}

void MenuUI::cb_Close_i(Fl_Menu_*, void*) {
  add_cb(14);
}
void MenuUI::cb_Close(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Close_i(o,v);
}

void MenuUI::cb_Menu2_i(Fl_Menu_*, void*) {
  add_cb(15);
}
void MenuUI::cb_Menu2(Fl_Menu_* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_Menu2_i(o,v);
}

unsigned char MenuUI::menu_Item_i18n_done = 0;
Fl_Menu_Item MenuUI::menu_Item[] = {
 {"Program", 0,  (Fl_Callback*)MenuUI::cb_Program, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Restart", 0,  (Fl_Callback*)MenuUI::cb_Restart, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Exit", 0,  (Fl_Callback*)MenuUI::cb_Exit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Separator", 0,  (Fl_Callback*)MenuUI::cb_Separator, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Include", 0,  (Fl_Callback*)MenuUI::cb_Include, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Desktops", 0,  (Fl_Callback*)MenuUI::cb_Desktops, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"SendTo", 0,  (Fl_Callback*)MenuUI::cb_SendTo, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Stick", 0,  (Fl_Callback*)MenuUI::cb_Stick, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Maximize", 0,  (Fl_Callback*)MenuUI::cb_Maximize, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Minimize", 0,  (Fl_Callback*)MenuUI::cb_Minimize, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Shade", 0,  (Fl_Callback*)MenuUI::cb_Shade, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Move", 0,  (Fl_Callback*)MenuUI::cb_Move, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Resize", 0,  (Fl_Callback*)MenuUI::cb_Resize, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Kill", 0,  (Fl_Callback*)MenuUI::cb_Kill, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Close", 0,  (Fl_Callback*)MenuUI::cb_Close, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Menu", 0,  (Fl_Callback*)MenuUI::cb_Menu2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void MenuUI::cb_prog_button_i(Fl_Button*, void*) {
  Apps apps;apps.loadTemp();
const char *f = "/usr/bin";
const char *m = "Choose a Program";
const char *p = "*";
int r = 0;
char *result = fl_file_chooser(m,p,f,r);
if(result!=NULL){
	prog_input->value(result);
	prog_input->redraw();
};
}
void MenuUI::cb_prog_button(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_prog_button_i(o,v);
}

void MenuUI::cb_OK1_i(Fl_Button*, void*) {
  configure_item();
config_flwin->hide();
}
void MenuUI::cb_OK1(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_OK1_i(o,v);
}

void MenuUI::cb_icon_button_i(Fl_Button*, void*) {
  Apps apps;apps.loadTemp();
const char *f = "/usr/share/pixmaps";
const char *m = "Choose an Icon";
const char *p = "*.{xbm,XBM,xpm,XPM,png,PNG,svg,SVG}";
int r = 0;
char *result = fl_file_chooser(m,p,f,r);
if(result!=NULL){
  prog_icon->value(result);
  prog_icon->redraw();
};
}
void MenuUI::cb_icon_button(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_icon_button_i(o,v);
}

void MenuUI::cb_OK2_i(Fl_Button*, void*) {
  save_cb();
}
void MenuUI::cb_OK2(Fl_Button* o, void* v) {
  ((MenuUI*)(o->parent()->user_data()))->cb_OK2_i(o,v);
}

Fl_Double_Window* MenuUI::make_window() {
  load();
  saveChangesTemp();
  { Fl_Double_Window* o = menu_window = new Fl_Double_Window(320, 315, gettext("Menu proerties"));
    menu_window->color((Fl_Color)31);
    menu_window->user_data((void*)(this));
    { Fl_Scroll* o = new Fl_Scroll(0, 0, 320, 315);
      o->color((Fl_Color)31);
      { Fl_Button* o = new Fl_Button(205, 235, 80, 30, gettext("Configure"));
        o->tooltip(gettext("Choose a program to add"));
        o->box(FL_GTK_UP_BOX);
        o->callback((Fl_Callback*)cb_Configure);
        o->align(Fl_Align(FL_ALIGN_WRAP));
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(190, 285, 57, 25, gettext("Cancel"));
        o->box(FL_GTK_UP_BOX);
        o->color((Fl_Color)80);
        o->selection_color((Fl_Color)81);
        o->labelcolor(FL_BACKGROUND2_COLOR);
        o->callback((Fl_Callback*)cb_Cancel);
      } // Fl_Button* o
      { save_button = new Fl_Button(256, 285, 49, 25, gettext("OK"));
        save_button->tooltip(gettext("Write to configuration file"));
        save_button->box(FL_GTK_UP_BOX);
        save_button->color((Fl_Color)61);
        save_button->selection_color((Fl_Color)59);
        save_button->labelcolor((Fl_Color)55);
        save_button->callback((Fl_Callback*)cb_save_button);
      } // Fl_Button* save_button
      { Fl_Button* o = new Fl_Button(10, 235, 65, 35, gettext("@+  Item"));
        o->tooltip(gettext("Add a menu item"));
        o->box(FL_GTK_UP_BOX);
        o->selection_color(FL_DARK1);
        o->callback((Fl_Callback*)cb_Item);
      } // Fl_Button* o
      { menuElement = new Fl_Browser(25, 80, 85, 140);
        menuElement->type(2);
        menuElement->box(FL_GTK_DOWN_BOX);
        menuElement->selection_color((Fl_Color)80);
        menuElement->callback((Fl_Callback*)cb_menuElement);
      } // Fl_Browser* menuElement
      { Fl_Button* o = new Fl_Button(80, 235, 70, 35, gettext(" Item"));
        o->tooltip(gettext("remove a menu item"));
        o->box(FL_GTK_UP_BOX);
        o->image(image_minus);
        o->callback((Fl_Callback*)cb_Item1);
        o->align(Fl_Align(256));
      } // Fl_Button* o
      { menuElementText = new Fl_Browser(120, 80, 185, 140);
        menuElementText->type(2);
        menuElementText->box(FL_GTK_DOWN_BOX);
        menuElementText->selection_color((Fl_Color)80);
        menuElementText->labeltype(FL_NO_LABEL);
        menuElementText->callback((Fl_Callback*)cb_menuElementText);
        menuElementText->align(Fl_Align(FL_ALIGN_TOP));
      } // Fl_Browser* menuElementText
      { Fl_Browser* o = root_menu = new Fl_Browser(130, 20, 80, 55, gettext("Root Menu "));
        root_menu->type(1);
        root_menu->box(FL_GTK_DOWN_BOX);
        root_menu->selection_color((Fl_Color)80);
        root_menu->callback((Fl_Callback*)cb_root_menu);
        root_menu->align(Fl_Align(FL_ALIGN_LEFT));
        Apps app;
        app.getMenus(o);
      } // Fl_Browser* root_menu
      { Fl_Button* o = new Fl_Button(10, 275, 65, 35, gettext("@+  Menu"));
        o->tooltip(gettext("Add a menu item"));
        o->box(FL_GTK_UP_BOX);
        o->selection_color(FL_DARK1);
        o->callback((Fl_Callback*)cb_Menu);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(80, 275, 70, 35, gettext(" Menu"));
        o->tooltip(gettext("remove a menu item"));
        o->box(FL_GTK_UP_BOX);
        o->image(image_minus);
        o->callback((Fl_Callback*)cb_Menu1);
        o->align(Fl_Align(256));
      } // Fl_Button* o
      o->end();
    } // Fl_Scroll* o
    Config config;config.under_mouse(o);
    menu_window->xclass("jsm-panel");
    menu_window->end();
    menu_window->resizable(menu_window);
  } // Fl_Double_Window* menu_window
  return menu_window;
}

Fl_Double_Window* MenuUI::add_window() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(350, 220, gettext("Add an Item"));
    w = o;
    o->user_data((void*)(this));
    { add_label = new Fl_Input(70, 70, 160, 25, gettext("Label"));
      add_label->box(FL_GTK_DOWN_BOX);
    } // Fl_Input* add_label
    { add_icon = new Fl_Input(70, 100, 160, 25, gettext("Icon"));
      add_icon->box(FL_GTK_DOWN_BOX);
    } // Fl_Input* add_icon
    { add_input = new Fl_Input(70, 130, 160, 25, gettext("Program"));
      add_input->box(FL_GTK_DOWN_BOX);
    } // Fl_Input* add_input
    { add_button = new Fl_Check_Button(75, 165, 90, 25, gettext("Confirm"));
      add_button->box(FL_GTK_DOWN_BOX);
      add_button->down_box(FL_GTK_DOWN_BOX);
    } // Fl_Check_Button* add_button
    { add_prog_button = new Fl_Button(235, 130, 90, 25, gettext("Choose"));
      add_prog_button->box(FL_GTK_UP_BOX);
      add_prog_button->callback((Fl_Callback*)cb_add_prog_button);
    } // Fl_Button* add_prog_button
    { Fl_Button* o = new Fl_Button(230, 160, 60, 25, gettext("OK"));
      o->box(FL_GTK_UP_BOX);
      o->color((Fl_Color)61);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_OK);
    } // Fl_Button* o
    { add_icon_button = new Fl_Button(235, 100, 90, 25, gettext("Choose"));
      add_icon_button->box(FL_GTK_UP_BOX);
      add_icon_button->callback((Fl_Callback*)cb_add_icon_button);
    } // Fl_Button* add_icon_button
    { Fl_Menu_Button* o = new Fl_Menu_Button(20, 20, 130, 25, gettext("Item to add"));
      o->box(FL_GTK_UP_BOX);
      if (!menu_Item_i18n_done) {
        int i=0;
        for ( ; i<16; i++)
          if (menu_Item[i].label())
            menu_Item[i].label(gettext(menu_Item[i].label()));
        menu_Item_i18n_done = 1;
      }
      o->menu(menu_Item);
    } // Fl_Menu_Button* o
    { item_display = new Fl_Output(175, 20, 130, 25);
      item_display->box(FL_GTK_DOWN_BOX);
    } // Fl_Output* item_display
    Config config;config.under_mouse(o);
    o->xclass("jsm-panel");
    o->end();
  } // Fl_Double_Window* o
  return w;
}

Fl_Double_Window* MenuUI::conf_window() {
  { Fl_Double_Window* o = config_flwin = new Fl_Double_Window(350, 145, gettext("Configure the Item"));
    config_flwin->user_data((void*)(this));
    { prog_label = new Fl_Input(80, 15, 160, 25, gettext("Label"));
      prog_label->box(FL_GTK_DOWN_BOX);
    } // Fl_Input* prog_label
    { prog_icon = new Fl_Input(80, 45, 160, 25, gettext("Icon"));
      prog_icon->box(FL_GTK_DOWN_BOX);
    } // Fl_Input* prog_icon
    { prog_input = new Fl_Input(80, 75, 160, 25, gettext("Program"));
      prog_input->box(FL_GTK_DOWN_BOX);
    } // Fl_Input* prog_input
    { conf_button = new Fl_Check_Button(85, 110, 90, 25, gettext("Confirm"));
      conf_button->box(FL_GTK_DOWN_BOX);
      conf_button->down_box(FL_GTK_DOWN_BOX);
    } // Fl_Check_Button* conf_button
    { prog_button = new Fl_Button(245, 75, 90, 25, gettext("Choose"));
      prog_button->box(FL_GTK_UP_BOX);
      prog_button->callback((Fl_Callback*)cb_prog_button);
    } // Fl_Button* prog_button
    { Fl_Button* o = new Fl_Button(240, 105, 60, 25, gettext("OK"));
      o->box(FL_GTK_UP_BOX);
      o->color((Fl_Color)61);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_OK1);
    } // Fl_Button* o
    { icon_button = new Fl_Button(245, 45, 90, 25, gettext("Choose"));
      icon_button->box(FL_GTK_UP_BOX);
      icon_button->callback((Fl_Callback*)cb_icon_button);
    } // Fl_Button* icon_button
    Config config;config.under_mouse(o);
    config_flwin->xclass("jsm-panel");
    config_flwin->end();
  } // Fl_Double_Window* config_flwin
  return config_flwin;
}

Fl_Double_Window* MenuUI::add_a_menu() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(300, 160, gettext("Add a Menu"));
    w = o;
    o->user_data((void*)(this));
    { Fl_Browser* o = list_browser = new Fl_Browser(10, 40, 95, 115, gettext("Choose a menu value"));
      list_browser->tooltip(gettext("Determine which buttons on the root window activate the menu. This is a list \
of integers specifying buttons. The default is 123. Multiple root menus may be\
 used by specifying different buttons to activate them. Valid values in this l\
ist are 0 to 9 and a to z. The usual mouse buttons are 1 for the left button, \
2 for the middle button, 3 for the right button, and 4 and 5 for the scroll wh\
eel. Therefore, accessing root menus that are assigned to buttons 0, 6, 7, 8, \
9, or a letter will typically require the use of a tray button or key binding."));
      list_browser->type(2);
      list_browser->box(FL_GTK_DOWN_BOX);
      list_browser->selection_color((Fl_Color)80);
      list_browser->align(Fl_Align(129));
      Apps app;
      app.listMenus(o);
    } // Fl_Browser* list_browser
    { Fl_Input* o = new Fl_Input(170, 45, 120, 30, gettext("Label"));
      o->tooltip(gettext("The label to display at the top of the menu"));
      o->box(FL_GTK_DOWN_BOX);
    } // Fl_Input* o
    { Fl_Slider* o = new Fl_Slider(170, 85, 120, 30, gettext("Height"));
      o->tooltip(gettext("The height of each menu item in pixels 0 indicates that the height of the fon\
t will determine the height. The default is 0."));
      o->type(1);
      o->box(FL_GTK_DOWN_BOX);
      o->color((Fl_Color)41);
      o->maximum(100);
      o->align(Fl_Align(FL_ALIGN_LEFT));
    } // Fl_Slider* o
    { Fl_Check_Button* o = new Fl_Check_Button(190, 15, 25, 25, gettext("Labeled        "));
      o->tooltip(gettext("Determines if a label appears at the top of the menu"));
      o->down_box(FL_GTK_DOWN_BOX);
      o->align(Fl_Align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE));
    } // Fl_Check_Button* o
    { Fl_Button* o = new Fl_Button(225, 130, 60, 25, gettext("OK"));
      o->box(FL_GTK_UP_BOX);
      o->color((Fl_Color)61);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_OK2);
    } // Fl_Button* o
    Config config;config.under_mouse(o);
    o->xclass("jsm-panel");
    o->end();
  } // Fl_Double_Window* o
  return w;
}

void MenuUI::add_an_item() {
  add_window()->show();
}

void MenuUI::add_cb(int whichOne) {
  //Program 0
  //Restart 1
  //Exit 2
  //Separator 3
  //Include 4
  //Desktops 5
  //SendTo 6
  //Stick 7
  //Maximize 8
  //Minimize 9
  //Shade 10
  //Move 11
  //Resize 12
  //Kill 13
  //Close 14
  //Menu (height,label,icon,labeled)
  add_prog_button->hide();
  add_input->hide();
  add_button->hide();
  add_label->show();
  add_icon->show();
  add_icon_button->show();
  
  Apps app;
  std::string result;
  switch (whichOne){
    case 0:
      result="Program";
      add_prog_button->show();
      add_input->show();
      break;
    case 1:
      result="Restart";
      break;
    case 2:
      result="Exit";
      add_button->show();
      add_button->copy_label("Confirm");
      break;
    case 3:
      result="Separator";
      add_label->hide();
      add_icon->hide();
      add_icon_button->hide();
      break;
    case 4:
      result="Include";
      add_input->show();
      add_label->hide();
      add_icon->hide();
      add_icon_button->hide();
      break;
    case 5:
      result="Desktops";
      break;
    case 6:
      result="SendTo";
      break;
    case 7:
      result="Stick";
      break;
    case 8:
      result="Maximize";
      break;
    case 9:
      result="Minimize";
      break;
    case 10:
      result="Shade";
      break;
    case 11:
      result="Move";
      break;
    case 12:
      result="Resize";
      break;
    case 13:
      result="Kill";
      break;
    case 14:
      result="Close";
      break;
    case 15:
      result="Menu";
      add_button->show();
      add_button->copy_label("Labeled");
      break;
  }
  item_display->value(result.c_str());
}

void MenuUI::choose_menu(const char* menu) {
  Apps app;
  app.getMenuItems(menuElement,menu,menuElementText);
  menuElementText->copy_label(menu);
}

void MenuUI::configure_item() {
  Apps app;
  int LINEposition = menuElement->value();
  std::string NAME = menuElement->text(LINEposition);
  app.ConfigMenuItem(menuElement,menuElementText,prog_label,prog_icon,prog_input,conf_button);
  const char* menu = menuElementText->label();
  choose_menu(menu);
}

void MenuUI::confirm_check() {
  int LINEposition = menuElement->value();
  std::string NAME = menuElement->text(LINEposition);
  if(NAME.compare("Exit")!=0){conf_button->hide();}
}

void MenuUI::edit_an_item() {
  conf_window()->show();
}

void MenuUI::program_check() {
  int LINEposition = menuElement->value();
  std::string NAME = menuElement->text(LINEposition);
  if(NAME.compare("Program")!=0){
    prog_button->hide();
    prog_input->hide();
  }
  else{
    std::string TEXT = menuElementText->text(LINEposition);
    //prog_input->value(TEXT.c_str());
    //how do I do that??
  }
}

void MenuUI::remove_an_item() {
  std::cout<<"Remove"<<std::endl;
}

void MenuUI::remove_a_menu() {
  int line = root_menu->value();
  const char* value = root_menu->text(line);
  if(value==NULL){return;}
  Apps app;
  app.removeMenu(value);
  app.getMenus(root_menu);
  menuElement->clear();
  menuElementText->clear();
}

int MenuUI::save_cb() {
  //save
  const char* result = item_display->value();
  Apps app;
  return app.addMenuItem(menuElement, menuElementText, add_label, add_icon, add_input, add_button, result);
}
