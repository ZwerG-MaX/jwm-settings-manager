/*                 Joe's Window Manager Configuration
 *
 * This program configures JWM using pugixml and FLTK
 *
 *         Copyright (C) 2016  Israel <israeldahl@gmail.com>
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * This has been developed as a part of the ToriOS Project
 *
 *
 * You may redistribute this, but you must keep this comment in place
 * Jesus is my Lord, and if you don't like it feel free to ignore it.
 */
// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include <libintl.h>
#include "jwm-autostart.h"

void AutostartUI::cb_Cancel_i(Fl_Button*, void*) {
  cancel();
}
void AutostartUI::cb_Cancel(Fl_Button* o, void* v) {
  ((AutostartUI*)(o->parent()->parent()->user_data()))->cb_Cancel_i(o,v);
}

void AutostartUI::cb_save_button_i(Fl_Button*, void*) {
  const char* proggie = program_name->value();
if(proggie!=NULL){add_program_to_autostart(autoStartBrowser,proggie);};
}
void AutostartUI::cb_save_button(Fl_Button* o, void* v) {
  ((AutostartUI*)(o->parent()->parent()->user_data()))->cb_save_button_i(o,v);
}

void AutostartUI::cb_add_item_i(Fl_Button*, void*) {
  const char* proggie = program_name->value();
if(proggie==NULL){
  debug_out("Choose a program");
  choose_a_program(program_name);
}
else{
  const char* val="JWM";
  if(tabbies->value() == xdg_tab)val="XDG";
  if(val==NULL){
    std::cerr<<"No tab is correctly selected"<<std::endl;
    return;
  }
  std::string VAL=val;
  debug_out("Configuration for: "+VAL);
  if(VAL.compare("JWM")==0){
    std::string pro=proggie;
    if (pro.compare("")==0){choose_a_program(program_name);}
    else{
     debug_out("Adding:"+pro+":");
      add_program_to_autostart(autoStartBrowser,proggie);
    }
  }
  else{
    std::string desktopeditor=linuxcommon::term_out("which desktop-file-editor");
    if(desktopeditor.compare("")!=0){
      desktopeditor+=" ";
      desktopeditor+=xdgbrowser->text(xdgbrowser->value());
      int sys=system(desktopeditor.c_str());
      if(sys!=0){debug_out(desktopeditor+" did not work");}
    }
    else{debug_out("Desktop File editor was not found!");}
  }
}
program_name->value("");
program_name->redraw();
}
void AutostartUI::cb_add_item(Fl_Button* o, void* v) {
  ((AutostartUI*)(o->parent()->parent()->user_data()))->cb_add_item_i(o,v);
}

void AutostartUI::cb_remove_item_i(Fl_Button*, void*) {
  const char* val=browser_name->value();
if(val==NULL){
  std::cerr<<"No tab is correctly selected"<<std::endl;
  return;
}
std::string VAL=val;
if(VAL.compare("JWM")==0){remove_program_from_autostart(autoStartBrowser);}
else{remove_program_from_xdg_autostart(xdgbrowser);}
program_name->value("");
program_name->redraw();
}
void AutostartUI::cb_remove_item(Fl_Button* o, void* v) {
  ((AutostartUI*)(o->parent()->parent()->user_data()))->cb_remove_item_i(o,v);
}

#include <FL/Fl_Bitmap.H>
static const unsigned char idata_minus[] =
{0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,
0,0,0};
static Fl_Bitmap image_minus(idata_minus, 16, 16);

void AutostartUI::cb_jwm_tab_i(Fl_Group*, void*) {
  browser_name->value("JWM");
}
void AutostartUI::cb_jwm_tab(Fl_Group* o, void* v) {
  ((AutostartUI*)(o->parent()->parent()->parent()->user_data()))->cb_jwm_tab_i(o,v);
}

void AutostartUI::cb_xdg_tab_i(Fl_Group*, void*) {
  //browser_name->value("XDG");
}
void AutostartUI::cb_xdg_tab(Fl_Group* o, void* v) {
  ((AutostartUI*)(o->parent()->parent()->parent()->user_data()))->cb_xdg_tab_i(o,v);
}

void AutostartUI::cb_xdgbrowser_i(Fl_Browser* o, void*) {
  const char* chosen =o->text(o->value());
if(chosen!=NULL){
  program_name->value(chosen);
  program_name->redraw();
};
}
void AutostartUI::cb_xdgbrowser(Fl_Browser* o, void* v) {
  ((AutostartUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_xdgbrowser_i(o,v);
}

Fl_Double_Window* AutostartUI::make_window() {
  load();
  { Fl_Double_Window* o = autostart_window = new Fl_Double_Window(335, 270, gettext("Autostart Programs"));
    autostart_window->color((Fl_Color)31);
    autostart_window->user_data((void*)(this));
    { Fl_Scroll* o = new Fl_Scroll(0, 0, 335, 270);
      o->color((Fl_Color)31);
      { program_name = new Fl_Input(85, 205, 245, 30);
        program_name->tooltip(gettext("You can add extra arguments here"));
        program_name->box(FL_FLAT_BOX);
        program_name->selection_color(FL_DARK1);
        program_name->align(Fl_Align(FL_ALIGN_TOP));
        program_name->when(FL_WHEN_ENTER_KEY);
      } // Fl_Input* program_name
      { Fl_Button* o = new Fl_Button(215, 240, 57, 25, gettext("Cancel"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)80);
        o->selection_color((Fl_Color)38);
        o->labelcolor(FL_BACKGROUND2_COLOR);
        o->callback((Fl_Callback*)cb_Cancel);
      } // Fl_Button* o
      { save_button = new Fl_Button(281, 240, 49, 25, gettext("OK"));
        save_button->tooltip(gettext("Write to configuration file"));
        save_button->box(FL_FLAT_BOX);
        save_button->color((Fl_Color)61);
        save_button->selection_color((Fl_Color)38);
        save_button->labelcolor((Fl_Color)55);
        save_button->callback((Fl_Callback*)cb_save_button);
      } // Fl_Button* save_button
      { add_item = new Fl_Button(5, 205, 30, 30, gettext("@+"));
        add_item->tooltip(gettext("Add OR chose a program"));
        add_item->box(FL_FLAT_BOX);
        add_item->color((Fl_Color)23);
        add_item->selection_color((Fl_Color)38);
        add_item->callback((Fl_Callback*)cb_add_item);
      } // Fl_Button* add_item
      { remove_item = new Fl_Button(45, 205, 30, 30);
        remove_item->box(FL_FLAT_BOX);
        remove_item->color((Fl_Color)23);
        remove_item->selection_color((Fl_Color)38);
        remove_item->image(image_minus);
        remove_item->callback((Fl_Callback*)cb_remove_item);
      } // Fl_Button* remove_item
      { tabbies = new Fl_Tabs(0, 0, 335, 200);
        tabbies->box(FL_FLAT_BOX);
        { jwm_tab = new Fl_Group(0, 35, 335, 165, gettext("JWM"));
          jwm_tab->callback((Fl_Callback*)cb_jwm_tab);
          { Fl_Browser* o = autoStartBrowser = new Fl_Browser(10, 45, 315, 145);
            autoStartBrowser->type(2);
            autoStartBrowser->box(FL_FLAT_BOX);
            autoStartBrowser->selection_color((Fl_Color)55);
            populateFLBrowser(o,"StartupCommand");
          } // Fl_Browser* autoStartBrowser
          jwm_tab->end();
        } // Fl_Group* jwm_tab
        { xdg_tab = new Fl_Group(0, 35, 335, 165, gettext("XDG"));
          xdg_tab->callback((Fl_Callback*)cb_xdg_tab);
          xdg_tab->hide();
          xdg_tab->deactivate();
          { Fl_Browser* o = xdgbrowser = new Fl_Browser(10, 45, 315, 145);
            xdgbrowser->type(2);
            xdgbrowser->box(FL_FLAT_BOX);
            xdgbrowser->selection_color((Fl_Color)55);
            xdgbrowser->callback((Fl_Callback*)cb_xdgbrowser);
            listAutostartXDG(o);
          } // Fl_Browser* xdgbrowser
          xdg_tab->end();
        } // Fl_Group* xdg_tab
        tabbies->end();
      } // Fl_Tabs* tabbies
      { browser_name = new Fl_Input(95, 5, 220, 25);
        browser_name->box(FL_FLAT_BOX);
        browser_name->selection_color(FL_DARK1);
        browser_name->align(Fl_Align(FL_ALIGN_TOP));
        browser_name->when(FL_WHEN_ENTER_KEY);
        browser_name->hide();
      } // Fl_Input* browser_name
      o->end();
    } // Fl_Scroll* o
    startup(o,jsm_autostart_xpm);
    autostart_window->xclass("jsm-autostart");
    autostart_window->end();
    autostart_window->resizable(autostart_window);
  } // Fl_Double_Window* autostart_window
  return autostart_window;
}
