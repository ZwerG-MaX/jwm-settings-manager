/*                 Joe's Window Manager Configuration
 *
 * This program configures JWM using tinyxml2 and FLTK
 *
 *         Copyright (C) 2014  Israel <israel@torios.org>
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * This has been developed as a part of the ToriOS Project
 * This has been developed by Israel<israel@torios.org>
 *
 *
 * You may redistribute this, but you must keep this comment in place
 * Jesus is my Lord, and if you don't like it feel free to ignore it.
 */
// generated by Fast Light User Interface Designer (fluid) version 1.0302

#include <libintl.h>
#include "jwm-window.h"

void WindowUI::cb_Cancel_i(Fl_Button*, void*) {
  window_window->hide();
cancel();
UI ui;
ui.showSettings();
}
void WindowUI::cb_Cancel(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->user_data()))->cb_Cancel_i(o,v);
}

void WindowUI::cb_OK_i(Fl_Button*, void*) {
  saveJWMRC(window_window);
UI ui;
ui.showSettings();
}
void WindowUI::cb_OK(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->user_data()))->cb_OK_i(o,v);
}

void WindowUI::cb_a_title_color1_i(Fl_Button*, void*) {
  set_one_title_color(a_title_color1,a_title_color2,1);
}
void WindowUI::cb_a_title_color1(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_a_title_color1_i(o,v);
}

void WindowUI::cb_a_title_color2_i(Fl_Button*, void*) {
  set_two_title_colors(a_title_color1, a_title_color2,1);
}
void WindowUI::cb_a_title_color2(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_a_title_color2_i(o,v);
}

void WindowUI::cb_a_font_color_i(Fl_Button*, void*) {
  set_font_color(a_font_color, 1);
}
void WindowUI::cb_a_font_color(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_a_font_color_i(o,v);
}

void WindowUI::cb_a_border_color_i(Fl_Button*, void*) {
  set_border_color(a_border_color, 1);
}
void WindowUI::cb_a_border_color(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_a_border_color_i(o,v);
}

void WindowUI::cb_active_o_slider_i(Fl_Slider*, void*) {
  set_opacity(active_o_slider,active_o_slider_v,1);
}
void WindowUI::cb_active_o_slider(Fl_Slider* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_active_o_slider_i(o,v);
}

void WindowUI::cb_active_o_slider_v_i(Fl_Value_Input*, void*) {
  set_opacity(active_o_slider,active_o_slider_v,1);
}
void WindowUI::cb_active_o_slider_v(Fl_Value_Input* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_active_o_slider_v_i(o,v);
}

void WindowUI::cb_inactive_color_i(Fl_Button*, void*) {
  set_one_title_color(inactive_color, inactive_color2, 2);
}
void WindowUI::cb_inactive_color(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_inactive_color_i(o,v);
}

void WindowUI::cb_inactive_color2_i(Fl_Button*, void*) {
  set_two_title_colors(inactive_color, inactive_color2, 2);
}
void WindowUI::cb_inactive_color2(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_inactive_color2_i(o,v);
}

void WindowUI::cb_inactive_font_color_i(Fl_Button*, void*) {
  set_font_color(inactive_font_color, 2);
}
void WindowUI::cb_inactive_font_color(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_inactive_font_color_i(o,v);
}

void WindowUI::cb_inactive_border_color_i(Fl_Button*, void*) {
  set_border_color(inactive_border_color, 2);
}
void WindowUI::cb_inactive_border_color(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_inactive_border_color_i(o,v);
}

void WindowUI::cb_inactive_o_slider_i(Fl_Slider*, void*) {
  set_opacity(inactive_o_slider,inactive_o_slider_v,2);
}
void WindowUI::cb_inactive_o_slider(Fl_Slider* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_inactive_o_slider_i(o,v);
}

void WindowUI::cb_inactive_o_slider_v_i(Fl_Value_Input*, void*) {
  set_opacity(inactive_o_slider,inactive_o_slider_v,2);
}
void WindowUI::cb_inactive_o_slider_v(Fl_Value_Input* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_inactive_o_slider_v_i(o,v);
}

void WindowUI::cb_Maximize_i(Fl_Button*, void*) {
  choose_button("ButtonMaxActive");
}
void WindowUI::cb_Maximize(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Maximize_i(o,v);
}

void WindowUI::cb_max_a_image_i(Fl_Box* o, void*) {
  get_button(o,"ButtonMaxActive");
}
void WindowUI::cb_max_a_image(Fl_Box* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_max_a_image_i(o,v);
}

void WindowUI::cb_i_max_a_image_i(Fl_Box* o, void*) {
  get_button_inactive(o,"ButtonMaxActive");
}
void WindowUI::cb_i_max_a_image(Fl_Box* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_i_max_a_image_i(o,v);
}

void WindowUI::cb_Close_i(Fl_Button*, void*) {
  choose_button("ButtonClose");
}
void WindowUI::cb_Close(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Close_i(o,v);
}

void WindowUI::cb_close_image_i(Fl_Box* o, void*) {
  get_button(o,"ButtonClose");
}
void WindowUI::cb_close_image(Fl_Box* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_close_image_i(o,v);
}

void WindowUI::cb_i_close_image_i(Fl_Box* o, void*) {
  get_button_inactive(o,"ButtonClose");
}
void WindowUI::cb_i_close_image(Fl_Box* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_i_close_image_i(o,v);
}

void WindowUI::cb_Maximize1_i(Fl_Button*, void*) {
  choose_button("ButtonMax");
}
void WindowUI::cb_Maximize1(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Maximize1_i(o,v);
}

void WindowUI::cb_max_image_i(Fl_Box* o, void*) {
  get_button(o,"ButtonMax");
}
void WindowUI::cb_max_image(Fl_Box* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_max_image_i(o,v);
}

void WindowUI::cb_i_max_image_i(Fl_Box* o, void*) {
  get_button_inactive(o,"ButtonMax");
}
void WindowUI::cb_i_max_image(Fl_Box* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_i_max_image_i(o,v);
}

void WindowUI::cb_Minimize_i(Fl_Button*, void*) {
  choose_button("ButtonMin");
}
void WindowUI::cb_Minimize(Fl_Button* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Minimize_i(o,v);
}

void WindowUI::cb_min_image_i(Fl_Box* o, void*) {
  get_button(o,"ButtonMin");
}
void WindowUI::cb_min_image(Fl_Box* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_min_image_i(o,v);
}

void WindowUI::cb_i_min_image_i(Fl_Box* o, void*) {
  get_button_inactive(o,"ButtonMin");
}
void WindowUI::cb_i_min_image(Fl_Box* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_i_min_image_i(o,v);
}

void WindowUI::cb_b_slider_i(Fl_Slider* o, void*) {
  border_modifier(o,b_slider_v,2);
}
void WindowUI::cb_b_slider(Fl_Slider* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_b_slider_i(o,v);
}

void WindowUI::cb_b_slider_v_i(Fl_Value_Input* o, void*) {
  border_modifier(b_slider,o,1);
}
void WindowUI::cb_b_slider_v(Fl_Value_Input* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_b_slider_v_i(o,v);
}

void WindowUI::cb_t_slider_i(Fl_Slider*, void*) {
  title_bar_modifier(t_slider,t_slider_v,2);
}
void WindowUI::cb_t_slider(Fl_Slider* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_t_slider_i(o,v);
}

void WindowUI::cb_t_slider_v_i(Fl_Value_Input*, void*) {
  title_bar_modifier(t_slider,t_slider_v,1);
}
void WindowUI::cb_t_slider_v(Fl_Value_Input* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_t_slider_v_i(o,v);
}

void WindowUI::cb_Make_i(Fl_Menu_*, void*) {
  flWindow w;
const char *mode ="opaque";
w.setResize(mode);
}
void WindowUI::cb_Make(Fl_Menu_* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Make_i(o,v);
}

void WindowUI::cb_Show_i(Fl_Menu_*, void*) {
  flWindow w;
const char *mode ="outline";
w.setResize(mode);
}
void WindowUI::cb_Show(Fl_Menu_* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Show_i(o,v);
}

unsigned char WindowUI::menu_resize_menu_i18n_done = 0;
Fl_Menu_Item WindowUI::menu_resize_menu[] = {
 {"Make it an Opaque box", 0,  (Fl_Callback*)WindowUI::cb_Make, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Show an Outline only", 0,  (Fl_Callback*)WindowUI::cb_Show, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void WindowUI::cb_Make1_i(Fl_Menu_*, void*) {
  flWindow w;
const char *mode ="opaque";
w.setMoveMode(mode);
}
void WindowUI::cb_Make1(Fl_Menu_* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Make1_i(o,v);
}

void WindowUI::cb_Show1_i(Fl_Menu_*, void*) {
  flWindow w;
const char *mode ="outline";
w.setMoveMode(mode);
}
void WindowUI::cb_Show1(Fl_Menu_* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Show1_i(o,v);
}

unsigned char WindowUI::menu_move_menu_i18n_done = 0;
Fl_Menu_Item WindowUI::menu_move_menu[] = {
 {"Make it an Opaque box", 0,  (Fl_Callback*)WindowUI::cb_Make1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Show an Outline only", 0,  (Fl_Callback*)WindowUI::cb_Show1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void WindowUI::cb_The_i(Fl_Menu_*, void*) {
  flWindow w;
int i = snap_int->value();
const char *mode ="screen";
w.setSnap(mode,i);
}
void WindowUI::cb_The(Fl_Menu_* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_The_i(o,v);
}

void WindowUI::cb_The1_i(Fl_Menu_*, void*) {
  flWindow w;
int i = snap_int->value();
const char *mode ="border";
w.setSnap(mode,i);
}
void WindowUI::cb_The1(Fl_Menu_* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_The1_i(o,v);
}

void WindowUI::cb_No_i(Fl_Menu_*, void*) {
  flWindow w;
int i = 0;
const char *mode ="none";
w.setSnap(mode,i);
}
void WindowUI::cb_No(Fl_Menu_* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_No_i(o,v);
}

unsigned char WindowUI::menu_snap_menu_i18n_done = 0;
Fl_Menu_Item WindowUI::menu_snap_menu[] = {
 {"The Screen\'s Edges", 0,  (Fl_Callback*)WindowUI::cb_The, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"The Border of other Windows", 0,  (Fl_Callback*)WindowUI::cb_The1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"No snapping", 0,  (Fl_Callback*)WindowUI::cb_No, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void WindowUI::cb_snap_int_i(Fl_Value_Input* o, void*) {
  flWindow w;
int d = o->value();
w.setSnap(d);
}
void WindowUI::cb_snap_int(Fl_Value_Input* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_snap_int_i(o,v);
}

void WindowUI::cb_By_i(Fl_Menu_*, void*) {
  flWindow w;
const char *mode ="click";
w.setFocusModel(mode);
}
void WindowUI::cb_By(Fl_Menu_* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_By_i(o,v);
}

void WindowUI::cb_By1_i(Fl_Menu_*, void*) {
  flWindow w;
const char *mode ="sloppy";
w.setFocusModel(mode);
}
void WindowUI::cb_By1(Fl_Menu_* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_By1_i(o,v);
}

unsigned char WindowUI::menu_focus_menu_i18n_done = 0;
Fl_Menu_Item WindowUI::menu_focus_menu[] = {
 {"By Clicking on it", 0,  (Fl_Callback*)WindowUI::cb_By, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"By moving the mouse over it", 0,  (Fl_Callback*)WindowUI::cb_By1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void WindowUI::cb_a_b_slider_i(Fl_Slider* o, void*) {
  //flWindow w;
border_modifier(o,a_b_slider_v);

//int x_cb = o->value();
//a_b_slider_v->value(x_cb);
//setBorderWidth(x_cb);
}
void WindowUI::cb_a_b_slider(Fl_Slider* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_a_b_slider_i(o,v);
}

void WindowUI::cb_a_t_slider_i(Fl_Slider*, void*) {
  title_bar_modifier(a_t_slider,a_t_slider_v);
}
void WindowUI::cb_a_t_slider(Fl_Slider* o, void* v) {
  ((WindowUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_a_t_slider_i(o,v);
}

Fl_Double_Window* WindowUI::make_window() {
  load();
  saveChangesTemp();
  { Fl_Double_Window* o = window_window = new Fl_Double_Window(680, 390, gettext("Window Settings"));
    window_window->color((Fl_Color)31);
    window_window->user_data((void*)(this));
    { Fl_Scroll* o = new Fl_Scroll(0, 0, 680, 390);
      o->color((Fl_Color)31);
      { Fl_Button* o = new Fl_Button(510, 360, 55, 25, gettext("Cancel"));
        o->box(FL_GTK_UP_BOX);
        o->down_box(FL_GTK_DOWN_BOX);
        o->color((Fl_Color)80);
        o->selection_color((Fl_Color)81);
        o->labelcolor(FL_BACKGROUND2_COLOR);
        o->callback((Fl_Callback*)cb_Cancel);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(595, 360, 45, 25, gettext("OK"));
        o->tooltip(gettext("Write to configuration file"));
        o->box(FL_GTK_UP_BOX);
        o->down_box(FL_GTK_DOWN_BOX);
        o->color((Fl_Color)61);
        o->selection_color((Fl_Color)59);
        o->labelcolor((Fl_Color)55);
        o->callback((Fl_Callback*)cb_OK);
      } // Fl_Button* o
      { Fl_Tabs* o = new Fl_Tabs(0, 25, 680, 330);
        o->box(FL_PLASTIC_THIN_UP_BOX);
        { Fl_Group* o = new Fl_Group(10, 45, 670, 305, gettext("Appearance"));
          { Fl_Box* o = new Fl_Box(10, 55, 330, 175);
            o->box(FL_GTK_DOWN_BOX);
            o->color((Fl_Color)51);
          } // Fl_Box* o
          { Fl_Box* o = new Fl_Box(100, 60, 160, 25, gettext("Active Window"));
            o->labelfont(1);
            o->labelcolor((Fl_Color)35);
            o->align(Fl_Align(384));
          } // Fl_Box* o
          { Fl_Box* o = new Fl_Box(20, 100, 145, 25, gettext("Titlebar Background"));
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Box* o = new Fl_Box(180, 85, 60, 15, gettext("Color 1"));
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Button* o = a_title_color1 = new Fl_Button(180, 100, 60, 25);
            a_title_color1->box(FL_GTK_UP_BOX);
            a_title_color1->callback((Fl_Callback*)cb_a_title_color1);
            active_color_loader(o,1);
          } // Fl_Button* a_title_color1
          { Fl_Box* o = new Fl_Box(245, 85, 60, 15, gettext("Color 2"));
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Button* o = a_title_color2 = new Fl_Button(245, 100, 60, 25);
            a_title_color2->box(FL_GTK_UP_BOX);
            a_title_color2->callback((Fl_Callback*)cb_a_title_color2);
            active_color_loader(o,2);
          } // Fl_Button* a_title_color2
          { Fl_Box* o = new Fl_Box(15, 130, 160, 25, gettext("Font and Button Color"));
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Button* o = a_font_color = new Fl_Button(180, 130, 60, 25);
            a_font_color->box(FL_GTK_UP_BOX);
            a_font_color->callback((Fl_Callback*)cb_a_font_color);
            a_font_color->when(FL_WHEN_RELEASE_ALWAYS);
            font_color_loader(o,1);
          } // Fl_Button* a_font_color
          { Fl_Box* o = new Fl_Box(15, 160, 155, 25, gettext("Window Border Color"));
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Button* o = a_border_color = new Fl_Button(180, 160, 60, 25);
            a_border_color->box(FL_GTK_UP_BOX);
            a_border_color->callback((Fl_Callback*)cb_a_border_color);
            a_border_color->when(FL_WHEN_RELEASE_ALWAYS);
            border_color_loader(o,1);
          } // Fl_Button* a_border_color
          { Fl_Slider* o = active_o_slider = new Fl_Slider(180, 190, 90, 25, gettext("Opacity of Title Bar"));
            active_o_slider->tooltip(gettext("A compositor (like xcompmgr) must be installed"));
            active_o_slider->type(1);
            active_o_slider->box(FL_GTK_DOWN_BOX);
            active_o_slider->color((Fl_Color)41);
            active_o_slider->selection_color((Fl_Color)29);
            active_o_slider->step(0.01);
            active_o_slider->value(1);
            active_o_slider->callback((Fl_Callback*)cb_active_o_slider);
            active_o_slider->align(Fl_Align(FL_ALIGN_LEFT));
            active_o_slider->when(FL_WHEN_RELEASE);
            opacity_loader(o,1);
          } // Fl_Slider* active_o_slider
          { Fl_Value_Input* o = active_o_slider_v = new Fl_Value_Input(280, 190, 35, 25, gettext("%"));
            active_o_slider_v->box(FL_GTK_DOWN_BOX);
            active_o_slider_v->selection_color((Fl_Color)80);
            active_o_slider_v->labelsize(10);
            active_o_slider_v->value(1);
            active_o_slider_v->callback((Fl_Callback*)cb_active_o_slider_v);
            active_o_slider_v->align(Fl_Align(FL_ALIGN_RIGHT));
            active_o_slider_v->when(3);
            float v = active_o_slider->value();
            o->value(v*100);
          } // Fl_Value_Input* active_o_slider_v
          { Fl_Box* o = new Fl_Box(350, 55, 320, 175);
            o->box(FL_GTK_DOWN_BOX);
            o->color(FL_DARK2);
          } // Fl_Box* o
          { Fl_Box* o = new Fl_Box(385, 60, 220, 25, gettext("Background  Window"));
            o->labelfont(1);
            o->labelcolor(FL_GRAY0);
            o->align(Fl_Align(FL_ALIGN_WRAP));
          } // Fl_Box* o
          { Fl_Box* o = new Fl_Box(360, 105, 140, 25, gettext("Titlebar Background"));
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Box* o = new Fl_Box(515, 85, 60, 15, gettext("Color 1"));
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Button* o = inactive_color = new Fl_Button(515, 100, 60, 25);
            inactive_color->box(FL_GTK_UP_BOX);
            inactive_color->callback((Fl_Callback*)cb_inactive_color);
            inactive_color->when(FL_WHEN_RELEASE_ALWAYS);
            inactive_color_loader(o,1);
          } // Fl_Button* inactive_color
          { Fl_Box* o = new Fl_Box(580, 85, 60, 15, gettext("Color 2"));
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Button* o = inactive_color2 = new Fl_Button(580, 100, 60, 25);
            inactive_color2->box(FL_GTK_UP_BOX);
            inactive_color2->callback((Fl_Callback*)cb_inactive_color2);
            inactive_color2->when(FL_WHEN_RELEASE_ALWAYS);
            inactive_color_loader(o,1);
          } // Fl_Button* inactive_color2
          { Fl_Box* o = new Fl_Box(355, 132, 160, 25, gettext("Font and Button Color"));
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Button* o = inactive_font_color = new Fl_Button(515, 130, 60, 25);
            inactive_font_color->box(FL_GTK_UP_BOX);
            inactive_font_color->callback((Fl_Callback*)cb_inactive_font_color);
            inactive_font_color->when(FL_WHEN_RELEASE_ALWAYS);
            font_color_loader(o,2);
          } // Fl_Button* inactive_font_color
          { Fl_Box* o = new Fl_Box(355, 160, 155, 25, gettext("Window Border Color"));
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Button* o = inactive_border_color = new Fl_Button(515, 160, 60, 25);
            inactive_border_color->box(FL_GTK_UP_BOX);
            inactive_border_color->callback((Fl_Callback*)cb_inactive_border_color);
            inactive_border_color->when(FL_WHEN_RELEASE_ALWAYS);
            border_color_loader(o,2);
          } // Fl_Button* inactive_border_color
          { Fl_Slider* o = inactive_o_slider = new Fl_Slider(500, 190, 90, 25, gettext("Opacity of Title Bar"));
            inactive_o_slider->tooltip(gettext("A compositor (like xcompmgr) must be installed"));
            inactive_o_slider->type(1);
            inactive_o_slider->box(FL_GTK_DOWN_BOX);
            inactive_o_slider->color((Fl_Color)41);
            inactive_o_slider->selection_color((Fl_Color)29);
            inactive_o_slider->step(0.01);
            inactive_o_slider->value(1);
            inactive_o_slider->callback((Fl_Callback*)cb_inactive_o_slider);
            inactive_o_slider->align(Fl_Align(FL_ALIGN_LEFT));
            inactive_o_slider->when(FL_WHEN_RELEASE);
            opacity_loader(o,2);
          } // Fl_Slider* inactive_o_slider
          { Fl_Value_Input* o = inactive_o_slider_v = new Fl_Value_Input(614, 190, 35, 25, gettext("%"));
            inactive_o_slider_v->box(FL_GTK_DOWN_BOX);
            inactive_o_slider_v->selection_color((Fl_Color)80);
            inactive_o_slider_v->labelsize(10);
            inactive_o_slider_v->callback((Fl_Callback*)cb_inactive_o_slider_v);
            inactive_o_slider_v->align(Fl_Align(FL_ALIGN_RIGHT));
            inactive_o_slider_v->when(3);
            float v = inactive_o_slider->value();
            o->value(v*100);
          } // Fl_Value_Input* inactive_o_slider_v
          { Fl_Box* o = new Fl_Box(205, 235, 315, 25, gettext("Change the Window Button Images"));
            o->labelfont(1);
            o->labelcolor((Fl_Color)35);
          } // Fl_Box* o
          { Fl_Button* o = new Fl_Button(40, 260, 225, 25, gettext(" Maximize Button (Activated)"));
            o->tooltip(gettext("Choose an image (XBM) for the Maximized button"));
            o->box(FL_GTK_UP_BOX);
            o->callback((Fl_Callback*)cb_Maximize);
            o->align(Fl_Align(256));
          } // Fl_Button* o
          { Fl_Box* o = max_a_image = new Fl_Box(275, 260, 30, 30);
            max_a_image->box(FL_GTK_DOWN_BOX);
            max_a_image->color((Fl_Color)43);
            max_a_image->callback((Fl_Callback*)cb_max_a_image);
            max_a_image->when(FL_WHEN_RELEASE_ALWAYS);
            get_button(o,"ButtonMaxActive");
          } // Fl_Box* max_a_image
          { Fl_Box* o = i_max_a_image = new Fl_Box(310, 260, 30, 30);
            i_max_a_image->box(FL_GTK_DOWN_BOX);
            i_max_a_image->color((Fl_Color)43);
            i_max_a_image->callback((Fl_Callback*)cb_i_max_a_image);
            i_max_a_image->when(FL_WHEN_RELEASE_ALWAYS);
            get_button_inactive(o,"ButtonMaxActive");
          } // Fl_Box* i_max_a_image
          { Fl_Button* o = new Fl_Button(150, 305, 115, 25, gettext("Close Button"));
            o->tooltip(gettext("Choose a XBM for the close button"));
            o->box(FL_GTK_UP_BOX);
            o->callback((Fl_Callback*)cb_Close);
            o->align(Fl_Align(256));
          } // Fl_Button* o
          { Fl_Box* o = close_image = new Fl_Box(275, 300, 30, 30);
            close_image->box(FL_GTK_DOWN_BOX);
            close_image->color((Fl_Color)43);
            close_image->callback((Fl_Callback*)cb_close_image);
            close_image->when(FL_WHEN_RELEASE_ALWAYS);
            get_button(o,"ButtonClose");
          } // Fl_Box* close_image
          { Fl_Box* o = i_close_image = new Fl_Box(310, 300, 30, 30);
            i_close_image->box(FL_GTK_DOWN_BOX);
            i_close_image->color((Fl_Color)43);
            i_close_image->callback((Fl_Callback*)cb_i_close_image);
            i_close_image->when(FL_WHEN_RELEASE_ALWAYS);
            get_button_inactive(o,"ButtonClose");
          } // Fl_Box* i_close_image
          { Fl_Button* o = new Fl_Button(395, 260, 145, 25, gettext("Maximize Button"));
            o->tooltip(gettext("Choose an image (XBM) for the Maximize button"));
            o->box(FL_GTK_UP_BOX);
            o->callback((Fl_Callback*)cb_Maximize1);
            o->align(Fl_Align(256));
          } // Fl_Button* o
          { Fl_Box* o = max_image = new Fl_Box(550, 260, 30, 30);
            max_image->box(FL_GTK_DOWN_BOX);
            max_image->color((Fl_Color)43);
            max_image->callback((Fl_Callback*)cb_max_image);
            max_image->when(FL_WHEN_RELEASE_ALWAYS);
            get_button(o,"ButtonMax");
          } // Fl_Box* max_image
          { Fl_Box* o = i_max_image = new Fl_Box(585, 260, 30, 30);
            i_max_image->box(FL_GTK_DOWN_BOX);
            i_max_image->color((Fl_Color)43);
            i_max_image->callback((Fl_Callback*)cb_i_max_image);
            i_max_image->when(FL_WHEN_RELEASE_ALWAYS);
            get_button_inactive(o,"ButtonMax");
          } // Fl_Box* i_max_image
          { Fl_Button* o = new Fl_Button(395, 305, 145, 25, gettext("Minimize Button"));
            o->tooltip(gettext("Choose an image (XBM) for the Minimize button"));
            o->box(FL_GTK_UP_BOX);
            o->callback((Fl_Callback*)cb_Minimize);
            o->align(Fl_Align(256));
          } // Fl_Button* o
          { Fl_Box* o = min_image = new Fl_Box(550, 300, 30, 30);
            min_image->box(FL_GTK_DOWN_BOX);
            min_image->color((Fl_Color)43);
            min_image->callback((Fl_Callback*)cb_min_image);
            min_image->when(FL_WHEN_RELEASE_ALWAYS);
            get_button(o,"ButtonMin");
          } // Fl_Box* min_image
          { Fl_Box* o = i_min_image = new Fl_Box(585, 300, 30, 30);
            i_min_image->box(FL_GTK_DOWN_BOX);
            i_min_image->color((Fl_Color)43);
            i_min_image->callback((Fl_Callback*)cb_i_min_image);
            i_min_image->when(FL_WHEN_RELEASE_ALWAYS);
            get_button_inactive(o,"ButtonMin");
          } // Fl_Box* i_min_image
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(100, 45, 525, 305, gettext("Settings"));
          o->hide();
          { Fl_Slider* o = b_slider = new Fl_Slider(325, 95, 125, 25, gettext("Size of the Window Frame"));
            b_slider->tooltip(gettext("This makes the edges of the window larger or smaller to help you grab them mo\
re easily"));
            b_slider->type(1);
            b_slider->box(FL_GTK_DOWN_BOX);
            b_slider->color((Fl_Color)41);
            b_slider->selection_color(FL_LIGHT1);
            b_slider->minimum(1);
            b_slider->maximum(28);
            b_slider->step(1);
            b_slider->value(4);
            b_slider->callback((Fl_Callback*)cb_b_slider);
            b_slider->align(Fl_Align(FL_ALIGN_LEFT));
            flWindow w;
            int x = w.getBorderWidth();
            o->value(x);
          } // Fl_Slider* b_slider
          { Fl_Value_Input* o = b_slider_v = new Fl_Value_Input(460, 95, 31, 25, gettext("pixels"));
            b_slider_v->box(FL_GTK_DOWN_BOX);
            b_slider_v->labelsize(10);
            b_slider_v->callback((Fl_Callback*)cb_b_slider_v);
            b_slider_v->align(Fl_Align(FL_ALIGN_RIGHT));
            b_slider_v->when(3);
            int v = b_slider->value();
            o->value(v);
          } // Fl_Value_Input* b_slider_v
          { Fl_Slider* o = t_slider = new Fl_Slider(325, 65, 125, 25, gettext("Window Title Bar Size"));
            t_slider->tooltip(gettext("This is the top with the program name, and close button, etc.."));
            t_slider->type(1);
            t_slider->box(FL_GTK_DOWN_BOX);
            t_slider->color((Fl_Color)41);
            t_slider->selection_color(FL_LIGHT1);
            t_slider->minimum(2);
            t_slider->maximum(78);
            t_slider->step(1);
            t_slider->value(20);
            t_slider->callback((Fl_Callback*)cb_t_slider);
            t_slider->align(Fl_Align(FL_ALIGN_LEFT));
            flWindow w;
            int y = w.getBorderHeight();
            o->value(y);
          } // Fl_Slider* t_slider
          { Fl_Value_Input* o = t_slider_v = new Fl_Value_Input(460, 65, 31, 25, gettext("pixels"));
            t_slider_v->box(FL_GTK_DOWN_BOX);
            t_slider_v->labelsize(10);
            t_slider_v->callback((Fl_Callback*)cb_t_slider_v);
            t_slider_v->align(Fl_Align(FL_ALIGN_RIGHT));
            t_slider_v->when(3);
            int v = t_slider->value();
            o->value(v);
          } // Fl_Value_Input* t_slider_v
          { resize_menu = new Fl_Menu_Button(170, 125, 325, 25, gettext("Appearance of the Window while Resizing"));
            resize_menu->tooltip(gettext("What the windows look like while resizing"));
            resize_menu->box(FL_GTK_UP_BOX);
            resize_menu->color((Fl_Color)48);
            resize_menu->selection_color(FL_DARK_RED);
            resize_menu->labelcolor((Fl_Color)35);
            resize_menu->textcolor((Fl_Color)35);
            if (!menu_resize_menu_i18n_done) {
              int i=0;
              for ( ; i<2; i++)
                if (menu_resize_menu[i].label())
                  menu_resize_menu[i].label(gettext(menu_resize_menu[i].label()));
              menu_resize_menu_i18n_done = 1;
            }
            resize_menu->menu(menu_resize_menu);
          } // Fl_Menu_Button* resize_menu
          { move_menu = new Fl_Menu_Button(180, 160, 305, 25, gettext("Appearance of Window while Moving"));
            move_menu->tooltip(gettext("What the windows look like while moving"));
            move_menu->box(FL_GTK_UP_BOX);
            move_menu->color((Fl_Color)48);
            move_menu->selection_color(FL_DARK_RED);
            move_menu->labelcolor((Fl_Color)35);
            move_menu->textcolor((Fl_Color)35);
            if (!menu_move_menu_i18n_done) {
              int i=0;
              for ( ; i<2; i++)
                if (menu_move_menu[i].label())
                  menu_move_menu[i].label(gettext(menu_move_menu[i].label()));
              menu_move_menu_i18n_done = 1;
            }
            move_menu->menu(menu_move_menu);
          } // Fl_Menu_Button* move_menu
          { snap_menu = new Fl_Menu_Button(180, 195, 310, 25, gettext("Choose what the Windows will snap to"));
            snap_menu->tooltip(gettext("This determines how windows \'Snap\' to other windows, and screen edges"));
            snap_menu->box(FL_GTK_UP_BOX);
            snap_menu->color((Fl_Color)48);
            snap_menu->selection_color(FL_DARK_RED);
            snap_menu->labelcolor((Fl_Color)35);
            snap_menu->textcolor((Fl_Color)35);
            if (!menu_snap_menu_i18n_done) {
              int i=0;
              for ( ; i<3; i++)
                if (menu_snap_menu[i].label())
                  menu_snap_menu[i].label(gettext(menu_snap_menu[i].label()));
              menu_snap_menu_i18n_done = 1;
            }
            snap_menu->menu(menu_snap_menu);
          } // Fl_Menu_Button* snap_menu
          { Fl_Value_Input* o = snap_int = new Fl_Value_Input(185, 225, 30, 25, gettext("How close (in pixels) does the window need to be to snap?"));
            snap_int->box(FL_GTK_DOWN_BOX);
            snap_int->labelsize(10);
            snap_int->minimum(1);
            snap_int->maximum(32);
            snap_int->step(1);
            snap_int->value(5);
            snap_int->callback((Fl_Callback*)cb_snap_int);
            snap_int->align(Fl_Align(FL_ALIGN_RIGHT));
            snap_int->when(3);
            flWindow w;
            int value = w.getSnap();
            o->value(value);
          } // Fl_Value_Input* snap_int
          { focus_menu = new Fl_Menu_Button(115, 255, 450, 25, gettext("Choose how the Window comes to the front of the screen"));
            focus_menu->tooltip(gettext("This determines how windows are brought to the front"));
            focus_menu->box(FL_GTK_UP_BOX);
            focus_menu->color((Fl_Color)48);
            focus_menu->selection_color(FL_DARK_RED);
            focus_menu->labelcolor((Fl_Color)35);
            focus_menu->textcolor((Fl_Color)35);
            if (!menu_focus_menu_i18n_done) {
              int i=0;
              for ( ; i<2; i++)
                if (menu_focus_menu[i].label())
                  menu_focus_menu[i].label(gettext(menu_focus_menu[i].label()));
              menu_focus_menu_i18n_done = 1;
            }
            focus_menu->menu(menu_focus_menu);
          } // Fl_Menu_Button* focus_menu
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(70, 50, 565, 295, gettext("Advanced"));
          o->hide();
          { Fl_Slider* o = a_b_slider = new Fl_Slider(270, 155, 125, 25, gettext("Window Border Size"));
            a_b_slider->tooltip(gettext("Width of the window borders"));
            a_b_slider->type(1);
            a_b_slider->box(FL_GTK_DOWN_BOX);
            a_b_slider->color((Fl_Color)41);
            a_b_slider->selection_color(FL_LIGHT1);
            a_b_slider->minimum(1);
            a_b_slider->maximum(128);
            a_b_slider->step(1);
            a_b_slider->value(4);
            a_b_slider->callback((Fl_Callback*)cb_a_b_slider);
            a_b_slider->align(Fl_Align(FL_ALIGN_LEFT));
            flWindow w;
            int x = w.getBorderWidth();
            o->value(x);
          } // Fl_Slider* a_b_slider
          { Fl_Value_Output* o = a_b_slider_v = new Fl_Value_Output(400, 155, 35, 25, gettext("pixels"));
            a_b_slider_v->box(FL_GTK_DOWN_BOX);
            a_b_slider_v->labelsize(10);
            a_b_slider_v->align(Fl_Align(FL_ALIGN_RIGHT));
            a_b_slider_v->when(3);
            int v = a_b_slider->value();
            o->value(v);
          } // Fl_Value_Output* a_b_slider_v
          { Fl_Slider* o = a_t_slider = new Fl_Slider(270, 195, 125, 25, gettext("Window Title Bar Size"));
            a_t_slider->tooltip(gettext("Height of the Window\'s Title Bar"));
            a_t_slider->type(1);
            a_t_slider->box(FL_GTK_DOWN_BOX);
            a_t_slider->color((Fl_Color)41);
            a_t_slider->selection_color(FL_LIGHT1);
            a_t_slider->minimum(2);
            a_t_slider->maximum(256);
            a_t_slider->step(1);
            a_t_slider->value(20);
            a_t_slider->callback((Fl_Callback*)cb_a_t_slider);
            a_t_slider->align(Fl_Align(FL_ALIGN_LEFT));
            flWindow w;
            int y = w.getBorderHeight();
            o->value(y);
          } // Fl_Slider* a_t_slider
          { Fl_Value_Output* o = a_t_slider_v = new Fl_Value_Output(400, 195, 35, 25, gettext("pixels"));
            a_t_slider_v->box(FL_GTK_DOWN_BOX);
            a_t_slider_v->labelsize(10);
            a_t_slider_v->align(Fl_Align(FL_ALIGN_RIGHT));
            a_t_slider_v->when(3);
            int v = a_t_slider->value();
            o->value(v);
          } // Fl_Value_Output* a_t_slider_v
          { new Fl_Box(150, 90, 355, 15, gettext("This can make your window borders and Title bar"));
          } // Fl_Box* o
          { Fl_Box* o = new Fl_Box(195, 105, 250, 50, gettext("REALLY HUGE!"));
            o->labelfont(1);
            o->labelsize(24);
          } // Fl_Box* o
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Tabs* o
      o->end();
    } // Fl_Scroll* o
    Config config;config.under_mouse(o);
    window_window->end();
    window_window->resizable(window_window);
  } // Fl_Double_Window* window_window
  return window_window;
}

void WindowUI::active_color_loader(Fl_Button *o, int one_or_two) {
  flWindow w;
  unsigned int color=0;
  unsigned int c = w.getActiveWindowColor(color);
  if(one_or_two ==1){o->color(c);}
  else{o->color(color);}
}

void WindowUI::border_color_loader(Fl_Widget *o, int Active1_Inactive2) {
  flWindow window;
      loadTemp();
  unsigned int colour=0;
  if (Active1_Inactive2==1){colour= window.getActiveBorderColor();}
  else{colour = window.getBorderColor();}
  o->color(colour);
}

void WindowUI::border_modifier(Fl_Slider *o1, Fl_Value_Input *o2, int change_o1_or_o2) {
  flWindow window;
  int whichone = 0;
  if(change_o1_or_o2==1){
    int input = o2->value();
    o1->value(input);
    whichone = input;
  }
  else{
    int slider = o1->value();
    o2->value(slider);
    whichone = slider;
  }
  window.setBorderWidth(whichone);
}

void WindowUI::border_modifier(Fl_Slider *o1, Fl_Value_Output *o2) {
  flWindow window;
  int slider = o1->value();
  o2->value(slider);
  window.setBorderWidth(slider);
}

void WindowUI::choose_button(const char* whichButton) {
  flWindow w;
  std::string label = "Choose ";
  label += whichButton;
  std::string tempPath = w.buttonPath();
  const char *path = tempPath.c_str();
  const char * f = path;
  const char * m=label.c_str();
  const char * p="*.{xbm,XBM,png,PNG,svg,SVG}";
  
  Fl_Native_File_Chooser fnfc;
  fnfc.title(m);
  fnfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
  fnfc.filter(p);
  fnfc.directory(f); // default directory to use
  // Show native chooser
  switch ( fnfc.show() ){
    case -1:
  //     printf("ERROR: %s\n", fnfc.errmsg());
       break; // ERROR
    case 1:
  //    printf("CANCEL\n");
      break; // CANCEL
    default:
      const char *result =fnfc.filename();
      if(result!=NULL){w.setButton(result,whichButton);}
      break; // FILE CHOSEN
  }
}

void WindowUI::display(const char* filename, Fl_Widget *o) {
  std::string extention, filenameStr;
  filenameStr = filename;
  extention = filenameStr.substr((strlen(filename)-4),4);
  std::transform(extention.begin(), extention.end(), extention.begin(), ::tolower);
  Fl_Image* image;
  std::string png =".png";
  std::string xpm =".xpm";
  if (extention.compare(png) ==0){
  	image = new Fl_PNG_Image(filename);
  	Fl_Image * image2 = image->copy(12,12);
  	o->image(image2);
  	o->redraw();
  }
  else if(extention.compare(xpm) ==0){
  	image = new Fl_XPM_Image(filename);
  	Fl_Image * image2 = image->copy(12,12);
  	o->image(image2);
  	o->redraw();
  }
}

void WindowUI::font_color_loader(Fl_Widget *o, int Active1_Inactive2) {
  flWindow window;
  unsigned int colour=0;
  if (Active1_Inactive2==1){colour= window.getActiveFontColor();}
  else{colour = window.getFontColor();}
  o->color(colour);
}

void WindowUI::get_button(Fl_Widget*o, const char* whichElement) {
  flWindow w;
      loadTemp();
  o->color(a_title_color1->color());
  o->labelcolor(a_font_color->color());
  const char * result = w.getButton(whichElement);
  //std::cout<<result<<std::endl;
  std::string test_result=result;
  if(test_result.compare("x")!=0){display(result,o);}
  o->redraw();
}

void WindowUI::get_button_inactive(Fl_Widget*o, const char* whichElement) {
  flWindow w;
      loadTemp();
  o->color(inactive_color->color());
  o->labelcolor(inactive_font_color->color());
  const char * result = w.getButton(whichElement);
  //std::cout<<result<<std::endl;
  std::string test_result=result;
  if(test_result.compare("x")!=0){display(result,o);}
  o->redraw();
}

void WindowUI::inactive_color_loader(Fl_Button *o, int one_or_two) {
  flWindow w;
  unsigned int color=0;
  unsigned int c = w.getWindowColor(color);
  if(one_or_two ==1){o->color(c);}
  else{o->color(color);}
}

void WindowUI::opacity_loader(Fl_Slider *o, int Active1_Inactive2) {
  flWindow window;
  float opacity;
  if (Active1_Inactive2==1){opacity= window.getActiveOpacity();}
  else{opacity = window.getOpacity();}
  o->value(opacity);
}

void WindowUI::set_border_color(Fl_Widget *o, int Active1_Inactive2) {
  flWindow w;
  uchar r;
  uchar g;
  uchar b;
  Fl::get_color((o->color()),r,g,b);
  
  int c;
  const char * label ="choose";
  c= fl_color_chooser(label,r,g,b,2);
  
  double* colors = new double[4];
  colors[0] = int(r); 
  colors[1] = int(g);
  colors[2] = int(b);
  colors[3] = 0;
  unsigned int current;
  if(c!=0){
    if (Active1_Inactive2==1){
  	current = w.getActiveBorderColor();
  	w.setActiveBorderColor(colors);
    }
    else{
  	current = w.getBorderColor();
  	w.setBorderColor(colors);
    }
    o->color(current);
    o->redraw();
  }
}

void WindowUI::set_font_color(Fl_Widget *o, int Active1_Inactive2) {
  flWindow w;
  uchar r;
  uchar g;
  uchar b;
  Fl::get_color((o->color()),r,g,b);
  
  int c;
  const char * label ="choose";
  c= fl_color_chooser(label,r,g,b,2);
  
  double* colors = new double[4];
  colors[0] = int(r); 
  colors[1] = int(g);
  colors[2] = int(b);
  colors[3] = 0;
  unsigned int current;
  if(c!=0){
  if (Active1_Inactive2==1){
  	w.setActiveFontColor(colors);
  	current = w.getActiveFontColor();
  }
  else{
  	w.setFontColor(colors);
  	current = w.getFontColor();
  }
  	o->color(current);
  	o->redraw();
  }
}

void WindowUI::set_one_title_color(Fl_Widget *o, Fl_Widget *o2, int Active1_Inactive2) {
  flWindow w;
  uchar r;
  uchar g;
  uchar b;
  Fl::get_color((o->color()),r,g,b);
  int c;
  const char * label ="choose";
  c= fl_color_chooser(label,r,g,b,2);
  double* colors = new double[4];
  colors[0] = int(r); 
  colors[1] = int(g);
  colors[2] = int(b);
  colors[3] = 0;
  
  uchar r2;
  uchar g2;
  uchar b2;
  
  Fl::get_color((o2->color()),r2,g2,b2);
  double*colors2 = new double[4];
  colors2[0] = int(r2); 
  colors2[1] = int(g2);
  colors2[2] = int(b2);
  colors2[3] = 0;
  
  unsigned int unusedColor;
  unsigned int colorSet;
  if(c!=0){ //If color chooser isn't canceled... do stuff
    if(Active1_Inactive2 ==1){
  	w.setActiveWindowColor(colors, colors2);
  	colorSet = w.getActiveWindowColor(unusedColor);
  	get_button(max_a_image,"ButtonMaxActive");
  	get_button(max_image,"ButtonMax");
  	get_button(min_image,"ButtonMin");
  	get_button(close_image,"ButtonClose");
    }
    else{
  	w.setWindowColor(colors, colors2);
  	colorSet = w.getWindowColor(unusedColor);
  	get_button_inactive(i_max_a_image,"ButtonMaxActive");
  	get_button_inactive(i_max_image,"ButtonMax");
  	get_button_inactive(i_min_image,"ButtonMin");
  	get_button_inactive(i_close_image,"ButtonClose");
    }
    o->color(colorSet);
    o->redraw();
  }
}

void WindowUI::set_opacity(Fl_Slider *o, Fl_Value_Input *o2, int Active1_or_Inactive2) {
  flWindow w;
  float opacity=o->value();
  if (Active1_or_Inactive2==1){w.activeWindowOpacity(opacity);}
  else{w.windowOpacity(opacity);}
  o2->value(opacity*100);
}

void WindowUI::set_two_title_colors(Fl_Widget *o, Fl_Widget *o2, int Active1_Inactive2) {
  flWindow w;
  uchar r;
  uchar g;
  uchar b;
  Fl::get_color((o->color()),r,g,b);
  
  double* colors = new double[4];
  colors[0] = int(r); 
  colors[1] = int(g);
  colors[2] = int(b);
  colors[3] = 0;
  
  uchar r2;
  uchar g2;
  uchar b2;
  Fl::get_color((o2->color()),r2,g2,b2);
  
  int c2;
  const char * label ="choose";
  c2= fl_color_chooser(label,r2,g2,b2,2);
  
  double*colors2 = new double[4];
  colors2[0] = int(r2); 
  colors2[1] = int(g2);
  colors2[2] = int(b2);
  colors2[3] = 0;
  unsigned int unusedColor;
  unsigned int colorSet;
  
  if (c2!=0){ //If the user doesn't cancel do stuff
  //Otherwise you will get weird colors
    if(Active1_Inactive2 ==1){
  	w.setActiveWindowColor(colors, colors2);
  	colorSet = w.getActiveWindowColor(unusedColor);
    }
    else{
  	w.setWindowColor(colors, colors2);
  	colorSet = w.getWindowColor(unusedColor);
    }
    o->color(colorSet);
    o->redraw();
    o2->color(unusedColor);
    o2->redraw();
  }
}

void WindowUI::title_bar_modifier(Fl_Slider *o1, Fl_Value_Output *o2) {
  flWindow window;
  int slider = o1->value();
  o2->value(slider);
  window.setBorderHeight(slider);
}

void WindowUI::title_bar_modifier(Fl_Slider *o1, Fl_Value_Input *o2, int change_o1_or_o2) {
  flWindow window;
  int whichone = 0;
  if(change_o1_or_o2==1){
    int input = o2->value();
    o1->value(input);
    whichone = input;
  }
  else{
    int slider = o1->value();
    o2->value(slider);
    whichone = slider;
  }
  window.setBorderHeight(whichone);
}
