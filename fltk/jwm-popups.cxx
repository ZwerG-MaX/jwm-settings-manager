/*                 Joe's Window Manager Configuration
 *
 * This program configures JWM using pugixml and FLTK
 *
 *         Copyright (C) 2016  Israel <israeldahl@gmail.com>
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * This has been developed as a part of the ToriOS Project
 *
 *
 * You may redistribute this, but you must keep this comment in place
 * Jesus is my Lord, and if you don't like it feel free to ignore it.
 */
// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include <libintl.h>
#include "jwm-popups.h"

void PopupsUI::cb_outline_i(Fl_Button* o, void*) {
  set_color(o,"Outline");
}
void PopupsUI::cb_outline(Fl_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_outline_i(o,v);
}

void PopupsUI::cb_delay_out_i(Fl_Value_Input* o, void*) {
  delay_slider->value(o->value());
}
void PopupsUI::cb_delay_out(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_delay_out_i(o,v);
}

void PopupsUI::cb_delay_slider_i(Fl_Slider* o, void*) {
  delay_out->value(o->value());
}
void PopupsUI::cb_delay_slider(Fl_Slider* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_delay_slider_i(o,v);
}

void PopupsUI::cb_true_i(Fl_Menu_*, void*) {
  std::string value="true";
enabled(value);
}
void PopupsUI::cb_true(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_true_i(o,v);
}

void PopupsUI::cb_false_i(Fl_Menu_*, void*) {
  std::string value="false";
enabled(value);
}
void PopupsUI::cb_false(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_false_i(o,v);
}

void PopupsUI::cb_button_i(Fl_Menu_*, void*) {
  std::string value="button";
enabled(value);
}
void PopupsUI::cb_button(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_button_i(o,v);
}

void PopupsUI::cb_clock_i(Fl_Menu_*, void*) {
  std::string value="clock";
enabled(value);
}
void PopupsUI::cb_clock(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_clock_i(o,v);
}

void PopupsUI::cb_menu_i(Fl_Menu_*, void*) {
  std::string value="menu";
enabled(value);
}
void PopupsUI::cb_menu(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_menu_i(o,v);
}

void PopupsUI::cb_pager_i(Fl_Menu_*, void*) {
  std::string value="pager";
enabled(value);
}
void PopupsUI::cb_pager(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_pager_i(o,v);
}

void PopupsUI::cb_task_i(Fl_Menu_*, void*) {
  std::string value="task";
enabled(value);
}
void PopupsUI::cb_task(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_task_i(o,v);
}

unsigned char PopupsUI::menu_enabled_i18n_done = 0;
Fl_Menu_Item PopupsUI::menu_enabled[] = {
 {"true", 0,  (Fl_Callback*)PopupsUI::cb_true, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"false", 0,  (Fl_Callback*)PopupsUI::cb_false, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"button", 0,  (Fl_Callback*)PopupsUI::cb_button, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"clock", 0,  (Fl_Callback*)PopupsUI::cb_clock, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"menu", 0,  (Fl_Callback*)PopupsUI::cb_menu, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"pager", 0,  (Fl_Callback*)PopupsUI::cb_pager, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"task", 0,  (Fl_Callback*)PopupsUI::cb_task, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PopupsUI::cb_Text_i(Fl_Button* o, void*) {
  set_color(o,"Foreground");
}
void PopupsUI::cb_Text(Fl_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_Text_i(o,v);
}

void PopupsUI::cb_Background_i(Fl_Button* o, void*) {
  set_color(o,"Background");
}
void PopupsUI::cb_Background(Fl_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_Background_i(o,v);
}

void PopupsUI::cb_OK_i(Fl_Button*, void*) {
  saveChanges();
quit();
}
void PopupsUI::cb_OK(Fl_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_OK_i(o,v);
}

void PopupsUI::cb_Cancel_i(Fl_Button*, void*) {
  cancel();
}
void PopupsUI::cb_Cancel(Fl_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_Cancel_i(o,v);
}

void PopupsUI::cb_Notifications_i(Fl_Button*, void*) {
  dunst_window()->show();
}
void PopupsUI::cb_Notifications(Fl_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->parent()->user_data()))->cb_Notifications_i(o,v);
}

void PopupsUI::cb_Font_i(Fl_Button*, void*) {
  std::string attribute ="font";
}
void PopupsUI::cb_Font(Fl_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_Font_i(o,v);
}

void PopupsUI::cb_left_i(Fl_Menu_*, void*) {
  std::string value="left";
std::string attribute ="alignment";
}
void PopupsUI::cb_left(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_left_i(o,v);
}

void PopupsUI::cb_center_i(Fl_Menu_*, void*) {
  std::string value="center";
std::string attribute ="alignment";
}
void PopupsUI::cb_center(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_center_i(o,v);
}

void PopupsUI::cb_right_i(Fl_Menu_*, void*) {
  std::string value="right";
std::string attribute ="alignment";
}
void PopupsUI::cb_right(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_right_i(o,v);
}

unsigned char PopupsUI::menu_Alignment_i18n_done = 0;
Fl_Menu_Item PopupsUI::menu_Alignment[] = {
 {"left", 0,  (Fl_Callback*)PopupsUI::cb_left, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"center", 0,  (Fl_Callback*)PopupsUI::cb_center, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"right", 0,  (Fl_Callback*)PopupsUI::cb_right, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PopupsUI::cb_mouse_i(Fl_Menu_*, void*) {
  std::string value="mouse";
std::string attribute ="follow";
}
void PopupsUI::cb_mouse(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_mouse_i(o,v);
}

void PopupsUI::cb_keyboard_i(Fl_Menu_*, void*) {
  std::string value="keyboard";
std::string attribute ="follow";
}
void PopupsUI::cb_keyboard(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_keyboard_i(o,v);
}

void PopupsUI::cb_none_i(Fl_Menu_*, void*) {
  std::string value="none";
std::string attribute ="follow";
}
void PopupsUI::cb_none(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_none_i(o,v);
}

unsigned char PopupsUI::menu_Follow_i18n_done = 0;
Fl_Menu_Item PopupsUI::menu_Follow[] = {
 {"mouse", 0,  (Fl_Callback*)PopupsUI::cb_mouse, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"keyboard", 0,  (Fl_Callback*)PopupsUI::cb_keyboard, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"none", 0,  (Fl_Callback*)PopupsUI::cb_none, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PopupsUI::cb_auto_i(Fl_Menu_*, void*) {
  std::string value="auto";
std::string attribute ="separator_color";
}
void PopupsUI::cb_auto(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_auto_i(o,v);
}

void PopupsUI::cb_foreground_i(Fl_Menu_*, void*) {
  std::string value="foreground";
std::string attribute ="separator_color";
}
void PopupsUI::cb_foreground(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_foreground_i(o,v);
}

void PopupsUI::cb_frame_i(Fl_Menu_*, void*) {
  std::string value="frame";
std::string attribute ="separator_color";
}
void PopupsUI::cb_frame(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_frame_i(o,v);
}

void PopupsUI::cb_frame1_i(Fl_Menu_*, void*) {
  std::string value="color";
}
void PopupsUI::cb_frame1(Fl_Menu_* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_frame1_i(o,v);
}

unsigned char PopupsUI::menu_Separator_i18n_done = 0;
Fl_Menu_Item PopupsUI::menu_Separator[] = {
 {"auto", 0,  (Fl_Callback*)PopupsUI::cb_auto, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"foreground", 0,  (Fl_Callback*)PopupsUI::cb_foreground, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"frame", 0,  (Fl_Callback*)PopupsUI::cb_frame, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"frame", 0,  (Fl_Callback*)PopupsUI::cb_frame1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PopupsUI::cb_word_wrap_i(Fl_Check_Button* o, void*) {
  std::string attribute ="word_wrap";
if(o->value()==1){bounce_freq->deactivate();}
else{bounce_freq->activate();};
}
void PopupsUI::cb_word_wrap(Fl_Check_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_word_wrap_i(o,v);
}

void PopupsUI::cb_allow_markup_i(Fl_Check_Button*, void*) {
  std::string attribute ="allow_markup";
}
void PopupsUI::cb_allow_markup(Fl_Check_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_allow_markup_i(o,v);
}

void PopupsUI::cb_Format_i(Fl_Output*, void*) {
  std::string attribute ="format";
}
void PopupsUI::cb_Format(Fl_Output* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_Format_i(o,v);
}

void PopupsUI::cb_sort_i(Fl_Check_Button*, void*) {
  std::string attribute ="sort";
}
void PopupsUI::cb_sort(Fl_Check_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_sort_i(o,v);
}

void PopupsUI::cb_indicate_hidden_i(Fl_Check_Button*, void*) {
  std::string attribute ="indicate_hidden";
}
void PopupsUI::cb_indicate_hidden(Fl_Check_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_indicate_hidden_i(o,v);
}

void PopupsUI::cb_ignore_newline_i(Fl_Check_Button*, void*) {
  std::string attribute ="ignore_newline";
}
void PopupsUI::cb_ignore_newline(Fl_Check_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_ignore_newline_i(o,v);
}

void PopupsUI::cb_shrink_i(Fl_Check_Button*, void*) {
  std::string attribute ="shrink";
}
void PopupsUI::cb_shrink(Fl_Check_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_shrink_i(o,v);
}

void PopupsUI::cb_sticky_history_i(Fl_Check_Button*, void*) {
  std::string attribute ="sticky_history";
}
void PopupsUI::cb_sticky_history(Fl_Check_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_sticky_history_i(o,v);
}

void PopupsUI::cb_idle_threshold_i(Fl_Value_Input*, void*) {
  std::string attribute ="idle_threshold";
}
void PopupsUI::cb_idle_threshold(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_idle_threshold_i(o,v);
}

void PopupsUI::cb_show_indicators_i(Fl_Check_Button*, void*) {
  std::string attribute ="show_indicators";
}
void PopupsUI::cb_show_indicators(Fl_Check_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_show_indicators_i(o,v);
}

void PopupsUI::cb_geometry_i(Fl_Output*, void*) {
  std::string attribute ="geometry";
}
void PopupsUI::cb_geometry(Fl_Output* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_geometry_i(o,v);
}

void PopupsUI::cb_trans_slide_i(Fl_Slider* o, void*) {
  transparency->value(o->value());
}
void PopupsUI::cb_trans_slide(Fl_Slider* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_trans_slide_i(o,v);
}

void PopupsUI::cb_transparency_i(Fl_Value_Input* o, void*) {
  trans_slide->value(o->value());
}
void PopupsUI::cb_transparency(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_transparency_i(o,v);
}

void PopupsUI::cb_show_age_threshold_i(Fl_Value_Input*, void*) {
  std::string attribute = "show_age_threshold";
}
void PopupsUI::cb_show_age_threshold(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_show_age_threshold_i(o,v);
}

void PopupsUI::cb_monitor_i(Fl_Value_Input*, void*) {
  std::string attribute ="monitor";
}
void PopupsUI::cb_monitor(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_monitor_i(o,v);
}

void PopupsUI::cb_history_length_i(Fl_Value_Input*, void*) {
  std::string attribute ="history_length";
}
void PopupsUI::cb_history_length(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_history_length_i(o,v);
}

void PopupsUI::cb_line_height_i(Fl_Value_Input*, void*) {
  std::string attribute ="line_height";
}
void PopupsUI::cb_line_height(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_line_height_i(o,v);
}

void PopupsUI::cb_separator_height_i(Fl_Value_Input*, void*) {
  std::string attribute ="separator_height";
}
void PopupsUI::cb_separator_height(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_separator_height_i(o,v);
}

void PopupsUI::cb_padding_i(Fl_Value_Input*, void*) {
  std::string attribute ="padding";
}
void PopupsUI::cb_padding(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_padding_i(o,v);
}

void PopupsUI::cb_horizontal_padding_i(Fl_Value_Input*, void*) {
  std::string attribute ="horizontal_padding";
}
void PopupsUI::cb_horizontal_padding(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_horizontal_padding_i(o,v);
}

void PopupsUI::cb_startup_notification_i(Fl_Check_Button*, void*) {
  std::string attribute ="startup_notification";
}
void PopupsUI::cb_startup_notification(Fl_Check_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_startup_notification_i(o,v);
}

void PopupsUI::cb_dmenu_i(Fl_Output*, void*) {
  std::string attribute ="dmenu";
}
void PopupsUI::cb_dmenu(Fl_Output* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_dmenu_i(o,v);
}

void PopupsUI::cb_Frame_width_i(Fl_Value_Input*, void*) {
  std::string attribute ="width";
std::string element="frame";
}
void PopupsUI::cb_Frame_width(Fl_Value_Input* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_Frame_width_i(o,v);
}

void PopupsUI::cb_Frame_color_i(Fl_Button*, void*) {
  std::string element="frame";
std::string attribute="color";
}
void PopupsUI::cb_Frame_color(Fl_Button* o, void* v) {
  ((PopupsUI*)(o->parent()->user_data()))->cb_Frame_color_i(o,v);
}

Fl_Double_Window* PopupsUI::make_window() {
  { popup_window = new Fl_Double_Window(275, 220, gettext("Popups"));
    popup_window->color(FL_DARK2);
    popup_window->labelcolor(FL_BACKGROUND2_COLOR);
    popup_window->user_data((void*)(this));
    { Fl_Scroll* o = new Fl_Scroll(0, 0, 270, 215);
      o->tooltip(gettext("This controls the look of popup tooltips such as those shown when the mouse s\
its over a panel item."));
      { Fl_Button* o = outline = new Fl_Button(105, 40, 75, 25, gettext("Outline"));
        outline->tooltip(gettext("The color of the window  outline.  The  default  is black."));
        outline->box(FL_FLAT_BOX);
        outline->color((Fl_Color)23);
        outline->callback((Fl_Callback*)cb_outline);
        outline->align(Fl_Align(132));
        o->color(get_color("Outline"));
      } // Fl_Button* outline
      { delay_out = new Fl_Value_Input(185, 10, 25, 25, gettext("milliseconds"));
        delay_out->tooltip(gettext("The  delay  in milliseconds before popups activate. The default is 600."));
        delay_out->box(FL_FLAT_BOX);
        delay_out->selection_color(FL_DARK_RED);
        delay_out->labelsize(8);
        delay_out->callback((Fl_Callback*)cb_delay_out);
        delay_out->align(Fl_Align(FL_ALIGN_RIGHT));
      } // Fl_Value_Input* delay_out
      { delay_slider = new Fl_Slider(105, 10, 75, 25, gettext("Delay"));
        delay_slider->tooltip(gettext("The  delay  in milliseconds before popups activate. The default is 600."));
        delay_slider->type(1);
        delay_slider->box(FL_GTK_DOWN_BOX);
        delay_slider->color((Fl_Color)42);
        delay_slider->selection_color(FL_LIGHT1);
        delay_slider->maximum(1200);
        delay_slider->step(10);
        delay_slider->value(600);
        delay_slider->callback((Fl_Callback*)cb_delay_slider);
        delay_slider->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Slider* delay_slider
      { Fl_Menu_Button* o = new Fl_Menu_Button(10, 135, 85, 25, gettext("enabled"));
        o->tooltip(gettext("Determine if popups are shown. This is a comma-sep\342\200\220 arated  list  \
of one or more of the following: true (all enabled), false (no  popups  enable\
d),  button (tray buttons), clock (clocks), menu (menus), pager (pagers), and \
task (task list items).  The  default is true."));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->selection_color(FL_DARK_RED);
        if (!menu_enabled_i18n_done) {
          int i=0;
          for ( ; i<7; i++)
            if (menu_enabled[i].label())
              menu_enabled[i].label(gettext(menu_enabled[i].label()));
          menu_enabled_i18n_done = 1;
        }
        o->menu(menu_enabled);
      } // Fl_Menu_Button* o
      { Fl_Output* o = enabled_out = new Fl_Output(105, 135, 105, 25);
        enabled_out->tooltip(gettext("Determine if popups are shown. This is a comma-sep\342\200\220 arated  list  \
of one or more of the following: true (all enabled), false (no  popups  enable\
d),  button (tray buttons), clock (clocks), menu (menus), pager (pagers), and \
task (task list items).  The  default is true."));
        enabled_out->box(FL_FLAT_BOX);
        enabled_out->color((Fl_Color)55);
        enabled_out->selection_color(FL_DARK_RED);
        std::string val=getElementAttribute("PopupStyle","enabled");
        if(val.compare("")==0){val="true";}
        o->value(val.c_str());
      } // Fl_Output* enabled_out
      { Fl_Button* o = new Fl_Button(105, 70, 75, 25, gettext("Text"));
        o->tooltip(gettext("The text color"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Text);
        o->align(Fl_Align(132));
        o->color(get_color("Foreground"));
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(105, 100, 75, 25, gettext("Background"));
        o->tooltip(gettext("The background color"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Background);
        o->align(Fl_Align(132));
        o->color(get_color("Background"));
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(210, 190, 60, 25, gettext("OK"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)62);
        o->labelcolor(FL_BACKGROUND2_COLOR);
        o->callback((Fl_Callback*)cb_OK);
        o->align(Fl_Align(FL_ALIGN_WRAP));
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(140, 190, 65, 25, gettext("Cancel"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)80);
        o->labelcolor(FL_BACKGROUND2_COLOR);
        o->callback((Fl_Callback*)cb_Cancel);
        o->align(Fl_Align(FL_ALIGN_WRAP));
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(10, 190, 100, 25, gettext("Notifications"));
        o->tooltip(gettext("Sytem notification pop up windows"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Notifications);
        o->align(Fl_Align(FL_ALIGN_WRAP));
        o->hide();
        o->deactivate();
      } // Fl_Button* o
      o->end();
    } // Fl_Scroll* o
    popup_window->xclass("preferences-system-notifications");
    popup_window->end();
  } // Fl_Double_Window* popup_window
  return popup_window;
}

Fl_Double_Window* PopupsUI::dunst_window() {
  { Fl_Double_Window* o = dunst_win = new Fl_Double_Window(515, 580, gettext("System Notifications"));
    dunst_win->user_data((void*)(this));
    { Fl_Button* o = new Fl_Button(10, 5, 125, 25, gettext("Font"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)23);
      o->callback((Fl_Callback*)cb_Font);
    } // Fl_Button* o
    { Fl_Output* o = font = new Fl_Output(150, 5, 90, 25);
      font->box(FL_FLAT_BOX);
      font->selection_color((Fl_Color)80);
      std::string attribute ="font";
      dunst_input(o,attribute);
    } // Fl_Output* font
    { Fl_Menu_Button* o = new Fl_Menu_Button(10, 35, 125, 25, gettext("Alignment"));
      o->tooltip(gettext("Alignment of message text. Possible values are \"left\", \"center\" and \"rig\
ht\"."));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)23);
      o->selection_color(FL_DARK_RED);
      if (!menu_Alignment_i18n_done) {
        int i=0;
        for ( ; i<3; i++)
          if (menu_Alignment[i].label())
            menu_Alignment[i].label(gettext(menu_Alignment[i].label()));
        menu_Alignment_i18n_done = 1;
      }
      o->menu(menu_Alignment);
    } // Fl_Menu_Button* o
    { Fl_Output* o = alignment = new Fl_Output(150, 35, 90, 25);
      alignment->tooltip(gettext("Alignment of message text. Possible values are \"left\", \"center\" and \"rig\
ht\"."));
      alignment->box(FL_FLAT_BOX);
      alignment->selection_color((Fl_Color)80);
      std::string attribute ="alignment";
      dunst_input(o,attribute);
    } // Fl_Output* alignment
    { Fl_Menu_Button* o = new Fl_Menu_Button(10, 65, 125, 25, gettext("Follow"));
      o->tooltip(gettext("Display notification on focused monitor.  Possible modes are:   mouse: follow\
 mouse pointer   keyboard: follow window with keyboard focus   none: don\'t fo\
llow anything  \"keyboard\" needs a windowmanager that exports the _NET_ACTIVE\
_WINDOW property. This should be the case for almost all modern windowmanagers\
.  If this option is set to mouse or keyboard, the monitor option will be igno\
red."));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)23);
      o->selection_color(FL_DARK_RED);
      if (!menu_Follow_i18n_done) {
        int i=0;
        for ( ; i<3; i++)
          if (menu_Follow[i].label())
            menu_Follow[i].label(gettext(menu_Follow[i].label()));
        menu_Follow_i18n_done = 1;
      }
      o->menu(menu_Follow);
    } // Fl_Menu_Button* o
    { Fl_Output* o = follow = new Fl_Output(150, 65, 90, 25);
      follow->tooltip(gettext("Display notification on focused monitor.  Possible modes are:   mouse: follow\
 mouse pointer   keyboard: follow window with keyboard focus   none: don\'t fo\
llow anything  \"keyboard\" needs a windowmanager that exports the _NET_ACTIVE\
_WINDOW property. This should be the case for almost all modern windowmanagers\
.  If this option is set to mouse or keyboard, the monitor option will be igno\
red."));
      follow->box(FL_FLAT_BOX);
      follow->selection_color((Fl_Color)80);
      std::string attribute ="follow";
      dunst_input(o,attribute);
    } // Fl_Output* follow
    { Fl_Menu_Button* o = new Fl_Menu_Button(10, 95, 125, 25, gettext("Separator Color"));
      o->tooltip(gettext("Define a color for the separator. possible values are:  * auto: dunst tries t\
o find a color fitting to the background;  * foreground: use the same color as\
 the foreground;  * frame: use the same color as the frame;  * anything else w\
ill be interpreted as a X color."));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)23);
      o->selection_color(FL_DARK_RED);
      if (!menu_Separator_i18n_done) {
        int i=0;
        for ( ; i<4; i++)
          if (menu_Separator[i].label())
            menu_Separator[i].label(gettext(menu_Separator[i].label()));
        menu_Separator_i18n_done = 1;
      }
      o->menu(menu_Separator);
    } // Fl_Menu_Button* o
    { Fl_Output* o = separator_color = new Fl_Output(150, 95, 90, 25);
      separator_color->tooltip(gettext("Define a color for the separator. possible values are:  * auto: dunst tries t\
o find a color fitting to the background;  * foreground: use the same color as\
 the foreground;  * frame: use the same color as the frame;  * anything else w\
ill be interpreted as a X color."));
      separator_color->box(FL_FLAT_BOX);
      separator_color->selection_color((Fl_Color)80);
      std::string attribute ="separator_color";
      dunst_input(o,attribute);
    } // Fl_Output* separator_color
    { Fl_Check_Button* o = word_wrap = new Fl_Check_Button(10, 125, 90, 25, gettext("Word wrap"));
      word_wrap->tooltip(gettext("Split notifications into multiple lines if they don\'t fit into geometery"));
      word_wrap->down_box(FL_GTK_DOWN_BOX);
      word_wrap->color(FL_BACKGROUND2_COLOR);
      word_wrap->selection_color((Fl_Color)2);
      word_wrap->callback((Fl_Callback*)cb_word_wrap);
      std::string attribute ="word_wrap";
      dunst_bool(o,"global",attribute);
    } // Fl_Check_Button* word_wrap
    { Fl_Value_Input* o = bounce_freq = new Fl_Value_Input(150, 125, 25, 20, gettext("Bounce Frequency"));
      bounce_freq->tooltip(gettext("The frequency with wich text that is longer than the notification window allo\
ws bounces back and forth. This option conflicts with \"word_wrap\". Set to 0 \
to disable."));
      bounce_freq->box(FL_FLAT_BOX);
      bounce_freq->selection_color((Fl_Color)80);
      bounce_freq->align(Fl_Align(FL_ALIGN_RIGHT));
      if(word_wrap->value()==1){o->deactivate();}
      std::string attribute = "bounce_freq";
      dunst_valuator(o,attribute);
    } // Fl_Value_Input* bounce_freq
    { Fl_Check_Button* o = allow_markup = new Fl_Check_Button(10, 150, 90, 25, gettext("Allow Markup"));
      allow_markup->tooltip(gettext("For a complete reference see <http://developer.gnome.org/pango/stable/PangoMa\
rkupFormat.html>. If markup is not allowed, those tags will be stripped out of\
 the message."));
      allow_markup->down_box(FL_GTK_DOWN_BOX);
      allow_markup->color(FL_BACKGROUND2_COLOR);
      allow_markup->selection_color((Fl_Color)2);
      allow_markup->callback((Fl_Callback*)cb_allow_markup);
      std::string attribute ="allow_markup";
      dunst_bool(o,"global",attribute);
    } // Fl_Check_Button* allow_markup
    { Fl_Output* o = new Fl_Output(150, 150, 150, 25, gettext("Format"));
      o->tooltip(gettext("The format of the message.  Possible variables are:   %a  appname   %s  summa\
ry   %b  body   %i  iconname (including its path)   %I  iconname (without its \
path)   %p  progress value if set ([  0%] to [100%]) or nothing"));
      o->box(FL_FLAT_BOX);
      o->selection_color((Fl_Color)80);
      o->callback((Fl_Callback*)cb_Format);
      o->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute ="format";
      dunst_input(o,attribute);
    } // Fl_Output* o
    { Fl_Check_Button* o = sort = new Fl_Check_Button(10, 170, 90, 25, gettext("Sort by urgency"));
      sort->tooltip(gettext("Sort messages by urgency."));
      sort->down_box(FL_GTK_DOWN_BOX);
      sort->color(FL_BACKGROUND2_COLOR);
      sort->selection_color((Fl_Color)2);
      sort->callback((Fl_Callback*)cb_sort);
      std::string attribute ="sort";
      dunst_bool(o,"global",attribute);
    } // Fl_Check_Button* sort
    { Fl_Check_Button* o = indicate_hidden = new Fl_Check_Button(10, 194, 90, 25, gettext("Indicate hidden"));
      indicate_hidden->tooltip(gettext("Show how many messages are currently hidden (because of geometry)."));
      indicate_hidden->down_box(FL_GTK_DOWN_BOX);
      indicate_hidden->color(FL_BACKGROUND2_COLOR);
      indicate_hidden->selection_color((Fl_Color)2);
      indicate_hidden->callback((Fl_Callback*)cb_indicate_hidden);
      std::string attribute ="indicate_hidden";
      dunst_bool(o,"global",attribute);
    } // Fl_Check_Button* indicate_hidden
    { Fl_Check_Button* o = ignore_newline = new Fl_Check_Button(10, 217, 140, 25, gettext("Ignore newlines"));
      ignore_newline->tooltip(gettext("Ignore newlines \'\\n\' in notifications."));
      ignore_newline->down_box(FL_GTK_DOWN_BOX);
      ignore_newline->color(FL_BACKGROUND2_COLOR);
      ignore_newline->selection_color((Fl_Color)2);
      ignore_newline->callback((Fl_Callback*)cb_ignore_newline);
      std::string attribute ="ignore_newline";
      dunst_bool(o,"global",attribute);
    } // Fl_Check_Button* ignore_newline
    { Fl_Check_Button* o = shrink = new Fl_Check_Button(10, 240, 140, 25, gettext("Shrink"));
      shrink->tooltip(gettext("Shrink window if it\'s smaller than the width.  Will be ignored if width is 0\
."));
      shrink->down_box(FL_GTK_DOWN_BOX);
      shrink->color(FL_BACKGROUND2_COLOR);
      shrink->selection_color((Fl_Color)2);
      shrink->callback((Fl_Callback*)cb_shrink);
      std::string attribute ="shrink";
      dunst_bool(o,"global",attribute);
    } // Fl_Check_Button* shrink
    { Fl_Check_Button* o = sticky_history = new Fl_Check_Button(10, 264, 140, 25, gettext("Sticky History"));
      sticky_history->tooltip(gettext("Should a notification popped up from history be sticky or timeout as if it wo\
uld normally do."));
      sticky_history->down_box(FL_GTK_DOWN_BOX);
      sticky_history->color(FL_BACKGROUND2_COLOR);
      sticky_history->selection_color((Fl_Color)2);
      sticky_history->callback((Fl_Callback*)cb_sticky_history);
      std::string attribute ="sticky_history";
      dunst_bool(o,"global",attribute);
    } // Fl_Check_Button* sticky_history
    { Fl_Value_Input* o = idle_threshold = new Fl_Value_Input(10, 370, 40, 20, gettext("idle threshold"));
      idle_threshold->tooltip(gettext("Don\'t remove messages, if the user is idle (no mouse or keyboard input) for \
longer than idle_threshold seconds. Set to 0 to disable."));
      idle_threshold->box(FL_FLAT_BOX);
      idle_threshold->selection_color((Fl_Color)80);
      idle_threshold->callback((Fl_Callback*)cb_idle_threshold);
      idle_threshold->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute ="idle_threshold";
      dunst_valuator(o,attribute);
    } // Fl_Value_Input* idle_threshold
    { Fl_Check_Button* o = show_indicators = new Fl_Check_Button(10, 287, 140, 25, gettext("Show Indicators"));
      show_indicators->tooltip(gettext("Display indicators for URLs (U) and actions (A)"));
      show_indicators->down_box(FL_GTK_DOWN_BOX);
      show_indicators->color(FL_BACKGROUND2_COLOR);
      show_indicators->selection_color((Fl_Color)2);
      show_indicators->callback((Fl_Callback*)cb_show_indicators);
      std::string attribute ="show_indicators";
      dunst_bool(o,"global",attribute);
    } // Fl_Check_Button* show_indicators
    { Fl_Output* o = geometry = new Fl_Output(10, 480, 175, 25, gettext("Geometery"));
      geometry->box(FL_FLAT_BOX);
      geometry->selection_color((Fl_Color)80);
      geometry->callback((Fl_Callback*)cb_geometry);
      geometry->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute ="geometry";
      dunst_input(o,attribute);
    } // Fl_Output* geometry
    { trans_slide = new Fl_Slider(10, 510, 90, 25);
      trans_slide->tooltip(gettext("The transparency of the window.  Range: [0; 100]. This option will only work \
if a compositing windowmanager is present (e.g. xcompmgr, compiz, etc.)."));
      trans_slide->type(1);
      trans_slide->box(FL_GTK_DOWN_BOX);
      trans_slide->color((Fl_Color)41);
      trans_slide->maximum(100);
      trans_slide->step(1);
      trans_slide->callback((Fl_Callback*)cb_trans_slide);
      trans_slide->align(Fl_Align(FL_ALIGN_LEFT));
    } // Fl_Slider* trans_slide
    { Fl_Value_Input* o = transparency = new Fl_Value_Input(110, 510, 25, 25, gettext("Transparency"));
      transparency->tooltip(gettext("The transparency of the window.  Range: [0; 100]. This option will only work \
if a compositing windowmanager is present (e.g. xcompmgr, compiz, etc.)."));
      transparency->box(FL_FLAT_BOX);
      transparency->selection_color((Fl_Color)80);
      transparency->maximum(100);
      transparency->step(1);
      transparency->callback((Fl_Callback*)cb_transparency);
      transparency->align(Fl_Align(FL_ALIGN_RIGHT));
      transparency->when(3);
      std::string attribute ="transparency";
      dunst_valuator(o,attribute);
      //trans_slide->value(o->value());
    } // Fl_Value_Input* transparency
    { Fl_Value_Input* o = show_age_threshold = new Fl_Value_Input(10, 345, 40, 20, gettext("Age threshold"));
      show_age_threshold->tooltip(gettext("Show age of message if message is older than this ammount in seconds"));
      show_age_threshold->box(FL_FLAT_BOX);
      show_age_threshold->selection_color((Fl_Color)80);
      show_age_threshold->callback((Fl_Callback*)cb_show_age_threshold);
      show_age_threshold->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute = "show_age_threshold";
      dunst_valuator(o,attribute);
    } // Fl_Value_Input* show_age_threshold
    { Fl_Value_Input* o = monitor = new Fl_Value_Input(10, 395, 40, 20, gettext("Monitor"));
      monitor->tooltip(gettext("Which monitor should the notifications be displayed on."));
      monitor->box(FL_FLAT_BOX);
      monitor->selection_color((Fl_Color)80);
      monitor->callback((Fl_Callback*)cb_monitor);
      monitor->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute ="monitor";
      dunst_valuator(o,attribute);
    } // Fl_Value_Input* monitor
    { Fl_Value_Input* o = history_length = new Fl_Value_Input(10, 420, 40, 20, gettext("History Length"));
      history_length->tooltip(gettext("Maximum amount of notifications kept in history"));
      history_length->box(FL_FLAT_BOX);
      history_length->selection_color((Fl_Color)80);
      history_length->callback((Fl_Callback*)cb_history_length);
      history_length->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute ="history_length";
      dunst_valuator(o,attribute);
    } // Fl_Value_Input* history_length
    { Fl_Value_Input* o = line_height = new Fl_Value_Input(185, 345, 45, 20, gettext("Line Height"));
      line_height->tooltip(gettext("The height of a single line.  If the height is smaller than the font height, \
it will get raised to the font height. This adds empty space above and under t\
he text."));
      line_height->box(FL_FLAT_BOX);
      line_height->selection_color((Fl_Color)80);
      line_height->callback((Fl_Callback*)cb_line_height);
      line_height->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute ="line_height";
      dunst_valuator(o,attribute);
    } // Fl_Value_Input* line_height
    { Fl_Value_Input* o = separator_height = new Fl_Value_Input(185, 370, 45, 20, gettext("Separator Height"));
      separator_height->tooltip(gettext("Draw a line of this pixel height between two notifications. Set to 0 to disab\
le."));
      separator_height->box(FL_FLAT_BOX);
      separator_height->selection_color((Fl_Color)80);
      separator_height->callback((Fl_Callback*)cb_separator_height);
      separator_height->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute ="separator_height";
      dunst_valuator(o,attribute);
    } // Fl_Value_Input* separator_height
    { Fl_Value_Input* o = padding = new Fl_Value_Input(185, 395, 45, 20, gettext("Text Padding"));
      padding->tooltip(gettext("Padding between text and separator."));
      padding->box(FL_FLAT_BOX);
      padding->selection_color((Fl_Color)80);
      padding->callback((Fl_Callback*)cb_padding);
      padding->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute ="padding";
      dunst_valuator(o,attribute);
    } // Fl_Value_Input* padding
    { Fl_Value_Input* o = horizontal_padding = new Fl_Value_Input(185, 420, 45, 20, gettext("Horizontal Padding"));
      horizontal_padding->tooltip(gettext("Padding between text and separator."));
      horizontal_padding->box(FL_FLAT_BOX);
      horizontal_padding->selection_color((Fl_Color)80);
      horizontal_padding->callback((Fl_Callback*)cb_horizontal_padding);
      horizontal_padding->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute ="horizontal_padding";
      dunst_valuator(o,attribute);
    } // Fl_Value_Input* horizontal_padding
    { Fl_Button* o = new Fl_Button(250, 95, 65, 25);
      o->tooltip(gettext("Choose a color"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)23);
    } // Fl_Button* o
    { Fl_Check_Button* o = startup_notification = new Fl_Check_Button(10, 310, 140, 25, gettext("Startup Notification"));
      startup_notification->tooltip(gettext("Print a notification on startup. This is mainly for error detection, since db\
us (re-)starts dunst automatically after a crash."));
      startup_notification->down_box(FL_GTK_DOWN_BOX);
      startup_notification->color(FL_BACKGROUND2_COLOR);
      startup_notification->selection_color((Fl_Color)2);
      startup_notification->callback((Fl_Callback*)cb_startup_notification);
      std::string attribute ="startup_notification";
      dunst_bool(o,"global",attribute);
    } // Fl_Check_Button* startup_notification
    { Fl_Output* o = dmenu = new Fl_Output(10, 445, 175, 25, gettext("Dmenu path"));
      dmenu->box(FL_FLAT_BOX);
      dmenu->selection_color((Fl_Color)80);
      dmenu->callback((Fl_Callback*)cb_dmenu);
      dmenu->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string attribute ="dmenu";
      dunst_input(o,attribute);
    } // Fl_Output* dmenu
    { Fl_Value_Input* o = Frame_width = new Fl_Value_Input(250, 210, 25, 20, gettext("Frame Width"));
      Frame_width->box(FL_FLAT_BOX);
      Frame_width->selection_color((Fl_Color)80);
      Frame_width->callback((Fl_Callback*)cb_Frame_width);
      Frame_width->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string element="frame";
      std::string attribute ="width";
      dunst_valuator(o,element,attribute);
    } // Fl_Value_Input* Frame_width
    { Fl_Button* o = Frame_color = new Fl_Button(250, 235, 70, 25, gettext("Frame Color"));
      Frame_color->box(FL_FLAT_BOX);
      Frame_color->color((Fl_Color)23);
      Frame_color->callback((Fl_Callback*)cb_Frame_color);
      Frame_color->align(Fl_Align(FL_ALIGN_RIGHT));
      std::string element="frame";
      std::string attribute="color";
      dunst_color(o,element,attribute);
    } // Fl_Button* Frame_color
    startup(o);
    debug_out("dunst window");
    dunst_win->xclass("preferences-system-notifications");
    dunst_win->end();
  } // Fl_Double_Window* dunst_win
  return dunst_win;
}

void PopupsUI::enabled(std::string value) {
  if(!setElementAttribute("PopupStyle","enabled",value)){
    debug_out("Could not set popup style");
  }
  enabled_out->value(value.c_str());
  enabled_out->redraw();
}

unsigned int PopupsUI::get_color(std::string element) {
  std::string color=getElementText("PopupStyle",element);
  return flCOLOR(color);
}

void PopupsUI::set_color(Fl_Widget*o,std::string element) {
  int retval=0;
  double* color = choose_a_color(retval,o);
  if(retval!=0){
    if(!setElementFloat("PopupStyle",element,color)){
      errorOUT("Could not set the color");
      return;
    }
    std::string tmp=getElementText("PopupStyle",element);
    unsigned int colorSet=flCOLOR(tmp);
    o->color(colorSet);
    o->redraw();
  }
}

std::string PopupsUI::get_dunst_global(std::string attribute) {
  return get_dunst("global",attribute);
}

void PopupsUI::set_dunst_global(std::string attribute) {
  set_dunst("global",attribute);
}

std::string PopupsUI::get_dunst(std::string element, std::string attribute) {
  debug_out("get_dunst("+element+","+attribute);
  std::string filename=linuxcommon::home_path();
  filename+=".config/dunst/dunstrc";
  std::string tmp= linuxcommon::get_line_with_equal(filename,attribute);
  unsigned int space=tmp.find(" ");
  if(space<tmp.length()){tmp=tmp.substr(space+1,std::string::npos);}
  debug_out("result="+tmp);
  return tmp;
}

void PopupsUI::set_dunst(std::string element, std::string attribute) {
  printf("Hello, World!\n");
}

void PopupsUI::dunst_input(Fl_Input *o,std::string element,std::string attribute) {
  std::string tmp=get_dunst(element,attribute);
  if(tmp.compare("")==0){
    debug_out(element+"->"+attribute+" contained nothing");
    return;
  }
  o->value(tmp.c_str());
  o->redraw();
}

void PopupsUI::dunst_valuator(Fl_Valuator *o,std::string element,std::string attribute) {
  std::string tmp=get_dunst(element,attribute);
  if(tmp.compare("")==0){
    debug_out(element+"->"+attribute+" contained nothing");
    return;
  }
  double val=linuxcommon::convert_string_to_double(tmp);
  o->value(val);
  o->redraw();
}

void PopupsUI::dunst_valuator(Fl_Valuator *o,std::string attribute) {
  //GLOBAL
  dunst_valuator(o,"global",attribute);
}

void PopupsUI::dunst_input(Fl_Input *o,std::string attribute) {
  //GLOBAL
  dunst_input(o,"global",attribute);
}

void PopupsUI::dunst_bool(Fl_Check_Button *o,std::string element,std::string attribute) {
  std::string tmp=get_dunst(element,attribute);
  if(tmp.compare("")==0){
    debug_out(element+"->"+attribute+" contained nothing");
    return;
  }
  std::transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);
  if((tmp.compare("true")==0)||(tmp.compare("yes")==0)){o->value(1);}
  else{o->value(0);}
}

void PopupsUI::dunst_color(Fl_Widget *o,std::string element,std::string attribute) {
  std::string tmp=get_dunst(element,attribute);
  if(tmp.compare("")==0){
    debug_out(element+"->"+attribute+" contained nothing");
    return;
  }
  unsigned int color=flCOLOR(tmp);
  o->color(color);
  o->redraw();
}
