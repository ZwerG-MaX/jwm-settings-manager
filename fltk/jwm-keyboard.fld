# data file for the Fltk User Interface Designer (fluid)
version 1.0302 
i18n_type 1 
i18n_include <libintl.h> 
i18n_function gettext 
header_name {.h} 
code_name {.cxx}
comment {/*                 Joe's Window Manager Configuration
 *
 * This program configures JWM using tinyxml2 and FLTK
 *
 *         Copyright (C) 2014  Israel <israel@torios.org>
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * This has been developed as a part of the ToriOS Project
 * This has been developed by Israel<israel@torios.org>
 *
 *
 * You may redistribute this, but you must keep this comment in place
 * Jesus is my Lord, and if you don't like it feel free to ignore it.
 */} {in_source in_header
} 

decl {\#include <libintl.h>} {public global
} 

decl {\#include <FL/Fl_File_Chooser.H>} {public global
} 

decl {\#include <string>} {public global
} 

decl {\#include <stdlib.h>} {public global
} 

decl {\#include <iostream>} {public global
} 

decl {\#include "../include/Config.h"} {public global
} 

decl {\#include "../include/flKeyboard.h"} {public global
} 

decl {\#include "../include/ui.h"} {public global
} 

decl {\#include "../data/icons/jsm-keyboard.xpm"} {public global
} 

class KeyboardUI {open : {public Config}
} {
  Function {make_window()} {open
  } {
    code {load();
saveChangesTemp();
//Fl::add_handler(handle);} {}
    Fl_Window keyboard_window {
      label {Keyboard Settings} open
      xywh {121 215 490 315} type Double color 31 resizable
      code0 {startup(o);} xclass {jsm-keyboard} visible
    } {
      Fl_Scroll {} {open
        xywh {0 0 490 310} color 31 resizable
      } {
        Fl_Browser key_browser {
          label {Keyboard Shortcuts}
          xywh {10 25 470 235} type Hold box FLAT_BOX selection_color 80 labelfont 1 align 1
          code1 {static int widths[] = {35,175,105,0};o->column_widths(widths);}
          code2 {flKeyboard keyboard;}
          code3 {keyboard.getKeys(key_browser);}
        }
        Fl_Button {} {
          label {-}
          callback {flKeyboard keyboard;
const char* mykey = key_browser->text(key_browser->value());
if(mykey==NULL){return;}
std::string keyShortcut = mykey;
if (keyShortcut.compare("")!=0){
	std::cout<<"Delete: "<<keyShortcut<<std::endl;
	keyboard.deleteKey(keyShortcut);
	key_browser->clear();
	keyboard.getKeys(key_browser);
	key_browser->redraw();
}
else{
	fl_message("Please click on an item to remove!");
}}
          xywh {60 270 35 30} box FLAT_BOX color 23 labelfont 1 labelsize 34
        }
        Fl_Button {} {
          label Cancel
          callback {cancel();
keyboard_window->hide();
UI ux;
ux.showSettings();}
          xywh {355 270 65 30} box FLAT_BOX color 80 selection_color 81 labelcolor 7
        }
        Fl_Button {} {
          label OK
          callback {saveJWMRC(keyboard_window);
UI ux;
ux.showSettings();} selected
          tooltip {Write to configuration file} xywh {430 270 45 30} box FLAT_BOX color 61 selection_color 59 labelcolor 55
        }
        Fl_Button {} {
          label {@+}
          callback {//Fl::add_handler(handle);
grabber_window()->show();}
          xywh {15 270 40 30} box FLAT_BOX color 23
        }
        Fl_Button {} {
          label Configure
          callback {flKeyboard keyboard;
const char* mykey = key_browser->text(key_browser->value());
if(mykey==NULL){return;}
std::string keyShortcut = mykey;
if (keyShortcut.compare("")!=0){
  std::string mod1,mod2,mod3,key,program;
  mod1=keyboard.getMod1(keyShortcut);
  mod2=keyboard.getMod2(keyShortcut);
  mod3=keyboard.getMod3(keyShortcut);
  key=keyboard.getKey(keyShortcut);
  program=keyboard.getAction(keyShortcut);
  config_key_win()->show();
  action_name1->value(program.c_str());
  keyshortcut->value(key.c_str());
  current_shortcut->value(keyShortcut.c_str());
  if(mod1.compare("")!=0){
    mod1_output->show();
    mod1_output->value(mod1.c_str());
  }
  if(mod2.compare("")!=0){
    mod2_output->show();
    mod2_output->value(mod2.c_str());
  }
  if(mod3.compare("")!=0){
    mod3_output->show();
    mod3_output->value(mod3.c_str());
  }
}
else{
  fl_message("Please click on an item to remove!");
}}
          xywh {110 270 85 30} box FLAT_BOX color 23 labelfont 1
        }
      }
    }
  }
  Function {grabber_window()} {open
  } {
    Fl_Window grab_win {
      label {Create Shortcut} open
      xywh {71 350 475 170} type Double when 6 hide
      code0 {startup(o);}
      code1 {Fl::focus(key);} xclass {jsm-keyboard}
    } {
      Fl_Button {} {
        label OK
        callback {add_cb();}
        xywh {390 125 65 30} box FLAT_BOX color 61 selection_color 58 labelcolor 7
      }
      Fl_Menu_Button {} {
        label Action
        xywh {200 90 125 30} box GTK_UP_BOX selection_color 80
      } {
        MenuItem next {
          label {move to the next window in the task list}
          callback {const char * action = "next";
menu_cb(action);}
          xywh {20 20 100 20}
        }
        MenuItem nextstacked {
          label {move to the next window in the stacking order}
          callback {const char * action = "nextstacked";
menu_cb(action);}
          xywh {30 30 100 20}
        }
        MenuItem prev {
          label {move to the previous window in the task list}
          callback {const char * action = "prev";
menu_cb(action);}
          xywh {30 30 100 20}
        }
        MenuItem prevstacked {
          label {move to the previous window in the stacking order}
          callback {const char * action = "prevstacked";
menu_cb(action);}
          xywh {40 40 100 20}
        }
        MenuItem close {
          label {close window}
          callback {const char * action = "close";
menu_cb(action);}
          xywh {40 40 100 20}
        }
        MenuItem fullscreen {
          label {fullscreen window}
          callback {const char * action = "fullscreen";
menu_cb(action);}
          xywh {50 50 100 20}
        }
        MenuItem minimize {
          label {minimize window}
          callback {const char * action = "minimize";
menu_cb(action);}
          xywh {60 60 100 20}
        }
        MenuItem maximize {
          label {maximize window}
          callback {const char * action = "maximize";
menu_cb(action);}
          xywh {70 70 100 20}
        }
        MenuItem shade {
          label {roll up window}
          callback {const char * action = "shade";
menu_cb(action);}
          xywh {80 80 100 20}
        }
        MenuItem move {
          label {move window}
          callback {const char * action = "move";
menu_cb(action);}
          xywh {90 90 100 20}
        }
        MenuItem resize {
          label {resize window}
          callback {const char * action = "resize";
menu_cb(action);}
          xywh {100 100 100 20}
        }
        MenuItem window {
          label {show window menu}
          callback {const char * action = "window";
menu_cb(action);}
          xywh {110 110 100 20}
        }
        MenuItem root_menu_apps {
          label {Show Application menu}
          callback {const char * action = "root:5";
menu_cb(action);}
          xywh {120 120 100 20}
        }
        MenuItem root_menu_places {
          label {Show Places Menu}
          callback {const char * action = "root:7";
menu_cb(action);}
          xywh {130 130 100 20}
        }
        MenuItem root_menu_shutdown {
          label {Show Shutdown menu}
          callback {const char * action = "root:9";
menu_cb(action);}
          xywh {140 140 100 20}
        }
        MenuItem rdesktop {
          label {move one desktop to the right}
          callback {const char * action = "rdesktop";
menu_cb(action);}
          xywh {100 100 100 20}
        }
        MenuItem ldesktop {
          label {move one desktop to the left}
          callback {const char * action = "ldesktop";
menu_cb(action);}
          xywh {110 110 100 20}
        }
        MenuItem udesktop {
          label {move one desktop up}
          callback {const char * action = "udesktop";
menu_cb(action);}
          xywh {120 120 100 20}
        }
        MenuItem ddesktop {
          label {move one desktop down}
          callback {const char * action = "ddesktop";
menu_cb(action);}
          xywh {130 130 100 20}
        }
        MenuItem restart {
          label {restart the Window Manager}
          callback {const char * action = "restart";
menu_cb(action);}
          xywh {140 140 100 20}
        }
        MenuItem exit {
          label {exit the Window Manager}
          callback {const char * action = "exit";
menu_cb(action);}
          xywh {150 150 100 20}
        }
        MenuItem showtray {
          label {Show any hidden Panels}
          callback {const char * action = "showtray";
menu_cb(action);}
          xywh {160 160 100 20}
        }
        MenuItem maxtop {
          label {Maximize to the Top of the screen}
          callback {if(newpanel()){
  const char * action = "maxtop";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {110 110 100 20}
        }
        MenuItem maxbottom {
          label {Maximize to the Bottom of the screen}
          callback {if(newpanel()){
  const char * action = "maxbottom";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {120 120 100 20}
        }
        MenuItem maxleft {
          label {Maximize to the Left of the screen}
          callback {if(newpanel()){
  const char * action = "maxleft";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {130 130 100 20}
        }
        MenuItem maxright {
          label {Maximize to the Right of the screen}
          callback {if(newpanel()){
  const char * action = "maxright";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {140 140 100 20}
        }
        MenuItem maxv {
          label {Maximize Vertical}
          callback {if(newpanel()){
  const char * action = "maxv";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {150 150 100 20}
        }
        MenuItem maxh {
          label {Maximize Horizontal}
          callback {if(newpanel()){
  const char * action = "maxh";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {160 160 100 20}
        }
        MenuItem sendu {
          label {Send Window Up a Desktop}
          callback {if(newpanel()){
  const char * action = "sendu";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {170 170 100 20}
        }
        MenuItem sendd {
          label {Send Window Down a Desktop}
          callback {if(newpanel()){
  const char * action = "sendd";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {180 180 100 20}
        }
        MenuItem sendr {
          label {Send Window Right a Desktop}
          callback {if(newpanel()){
  const char * action = "sendr";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {190 190 100 20}
        }
        MenuItem sendl {
          label {Send Window Left a Desktop}
          callback {if(newpanel()){
  const char * action = "sendl";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {200 200 100 20}
        }
      }
      Fl_Button {} {
        label {Choose Program}
        callback {std::string result = desktopFILE();
std::cout<<result<<std::endl;
std::string exec = "exec:";
exec+=result;
action_name->value(exec.c_str());}
        tooltip {Choose a program to add} xywh {10 90 140 30} box FLAT_BOX color 23
      }
      Fl_Input action_name {
        xywh {10 125 275 30} box FLAT_BOX align 129
      }
      Fl_Menu_Button key_mod {
        label {Choose a Key Modifier}
        tooltip {These are keys like Ctrl, Alt, Shift, and Super (Windows or Apple key)} xywh {5 15 195 30} box GTK_UP_BOX
      } {
        MenuItem C {
          label Ctrl
          callback {const char* mod = "C";
mod_cb(mod);}
          tooltip Control xywh {10 10 100 20}
        }
        MenuItem A {
          label Alt
          callback {const char* mod = "A";
mod_cb(mod);}
          xywh {10 10 100 20}
        }
        MenuItem mod4 {
          label Super
          callback {const char* mod = "4";
mod_cb(mod);}
          xywh {10 10 100 20}
        }
        MenuItem S {
          label Shift
          callback {const char* mod = "S";
mod_cb(mod);}
          xywh {10 10 100 20}
        }
      }
      Fl_Menu_Button key_mod2 {
        label {Choose a 2nd Key Modifier}
        tooltip {This is optional} xywh {5 55 230 30} box GTK_UP_BOX
      } {
        MenuItem {} {
          label Ctrl
          callback {const char* mod = "C";
mod2_cb(mod);}
          tooltip Control xywh {20 20 100 20}
        }
        MenuItem {} {
          label Alt
          callback {const char* mod = "A";
mod2_cb(mod);}
          xywh {20 20 100 20}
        }
        MenuItem {} {
          label Super
          callback {const char* mod = "4";
mod2_cb(mod);}
          xywh {20 20 100 20}
        }
        MenuItem {} {
          label Shift
          callback {const char* mod = "S";
mod2_cb(mod);}
          xywh {20 20 100 20}
        }
      }
      Fl_Input key {
        label Key
        callback {key_event();}
        xywh {275 40 135 30} box FLAT_BOX when 1
      }
      Fl_Box {} {
        label OR
        xywh {160 95 25 25}
      }
      Fl_Button {} {
        label Cancel
        callback {grab_win->hide();}
        xywh {300 125 65 30} box FLAT_BOX color 80 selection_color 64 labelcolor 7
      }
      Fl_Output mod_output {
        xywh {290 5 50 30} box GTK_DOWN_BOX hide
      }
      Fl_Output key_output {
        xywh {350 5 50 30} box GTK_DOWN_BOX hide
      }
    }
  }
  Function {config_key_win()} {open
  } {
    Fl_Window conf_key_win {open
      xywh {81 133 475 225} type Double hide
      code0 {startup(o);} xclass {jsm-keyboard}
    } {
      Fl_Button {} {
        label OK
        callback {configure_cb();}
        xywh {400 185 65 30} box FLAT_BOX color 61 selection_color 58 labelcolor 7
      }
      Fl_Menu_Button {} {
        label Action
        xywh {205 145 125 30} box GTK_UP_BOX selection_color 80
      } {
        MenuItem next1 {
          label {move to the next window in the task list}
          callback {const char * action = "next";
menu_cb(action);}
          xywh {30 30 100 20}
        }
        MenuItem nextstacked1 {
          label {move to the next window in the stacking order}
          callback {const char * action = "nextstacked";
menu_cb(action);}
          xywh {40 40 100 20}
        }
        MenuItem prev1 {
          label {move to the previous window in the task list}
          callback {const char * action = "prev";
menu_cb(action);}
          xywh {40 40 100 20}
        }
        MenuItem prevstacked1 {
          label {move to the previous window in the stacking order}
          callback {const char * action = "prevstacked";
menu_cb(action);}
          xywh {50 50 100 20}
        }
        MenuItem close1 {
          label {close window}
          callback {const char * action = "close";
menu_cb(action);}
          xywh {50 50 100 20}
        }
        MenuItem fullscreen1 {
          label {fullscreen window}
          callback {const char * action = "fullscreen";
menu_cb(action);}
          xywh {60 60 100 20}
        }
        MenuItem minimize1 {
          label {minimize window}
          callback {const char * action = "minimize";
menu_cb(action);}
          xywh {70 70 100 20}
        }
        MenuItem maximize1 {
          label {maximize window}
          callback {const char * action = "maximize";
menu_cb(action);}
          xywh {80 80 100 20}
        }
        MenuItem shade1 {
          label {roll up window}
          callback {const char * action = "shade";
menu_cb(action);}
          xywh {90 90 100 20}
        }
        MenuItem move1 {
          label {move window}
          callback {const char * action = "move";
menu_cb(action);}
          xywh {100 100 100 20}
        }
        MenuItem resize1 {
          label {resize window}
          callback {const char * action = "resize";
menu_cb(action);}
          xywh {110 110 100 20}
        }
        MenuItem window1 {
          label {show window menu}
          callback {const char * action = "window";
menu_cb(action);}
          xywh {120 120 100 20}
        }
        MenuItem root_menu_apps1 {
          label {Show Application menu}
          callback {const char * action = "root:5";
menu_cb(action);}
          xywh {130 130 100 20}
        }
        MenuItem root_menu_places1 {
          label {Show Places Menu}
          callback {const char * action = "root:7";
menu_cb(action);}
          xywh {140 140 100 20}
        }
        MenuItem root_menu_shutdown1 {
          label {Show Shutdown menu}
          callback {const char * action = "root:9";
menu_cb(action);}
          xywh {150 150 100 20}
        }
        MenuItem rdesktop1 {
          label {move one desktop to the right}
          callback {const char * action = "rdesktop";
menu_cb(action);}
          xywh {110 110 100 20}
        }
        MenuItem ldesktop1 {
          label {move one desktop to the left}
          callback {const char * action = "ldesktop";
menu_cb(action);}
          xywh {120 120 100 20}
        }
        MenuItem udesktop1 {
          label {move one desktop up}
          callback {const char * action = "udesktop";
menu_cb(action);}
          xywh {130 130 100 20}
        }
        MenuItem ddesktop1 {
          label {move one desktop down}
          callback {const char * action = "ddesktop";
menu_cb(action);}
          xywh {140 140 100 20}
        }
        MenuItem restart1 {
          label {restart the Window Manager}
          callback {const char * action = "restart";
menu_cb(action);}
          xywh {150 150 100 20}
        }
        MenuItem exit1 {
          label {exit the Window Manager}
          callback {const char * action = "exit";
menu_cb(action);}
          xywh {160 160 100 20}
        }
        MenuItem showtray1 {
          label {Show any hidden Panels}
          callback {const char * action = "showtray";
menu_cb(action);}
          xywh {170 170 100 20}
        }
        MenuItem maxtop1 {
          label {Maximize to the Top of the screen}
          callback {if(newpanel()){
  const char * action = "maxtop";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {120 120 100 20}
        }
        MenuItem maxbottom1 {
          label {Maximize to the Bottom of the screen}
          callback {if(newpanel()){
  const char * action = "maxbottom";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {130 130 100 20}
        }
        MenuItem maxleft1 {
          label {Maximize to the Left of the screen}
          callback {if(newpanel()){
  const char * action = "maxleft";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {140 140 100 20}
        }
        MenuItem maxright1 {
          label {Maximize to the Right of the screen}
          callback {if(newpanel()){
  const char * action = "maxright";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {150 150 100 20}
        }
        MenuItem maxv1 {
          label {Maximize Vertical}
          callback {if(newpanel()){
  const char * action = "maxv";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {160 160 100 20}
        }
        MenuItem maxh1 {
          label {Maximize Horizontal}
          callback {if(newpanel()){
  const char * action = "maxh";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {170 170 100 20}
        }
        MenuItem sendu1 {
          label {Send Window Up a Desktop}
          callback {if(newpanel()){
  const char * action = "sendu";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {180 180 100 20}
        }
        MenuItem sendd1 {
          label {Send Window Down a Desktop}
          callback {if(newpanel()){
  const char * action = "sendd";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {190 190 100 20}
        }
        MenuItem sendr1 {
          label {Send Window Right a Desktop}
          callback {if(newpanel()){
  const char * action = "sendr";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {200 200 100 20}
        }
        MenuItem sendl1 {
          label {Send Window Left a Desktop}
          callback {if(newpanel()){
  const char * action = "sendl";
  menu_cb(action);
}
else{
  o->hide();
}}
          xywh {210 210 100 20}
        }
      }
      Fl_Button {} {
        label {Choose Program}
        callback {std::string result = desktopFILE();
std::cout<<result<<std::endl;
std::string exec = "exec:";
exec+=result;
action_name1->value(exec.c_str());}
        tooltip {Choose a program to add} xywh {15 145 140 30} box FLAT_BOX color 23
      }
      Fl_Input action_name1 {
        xywh {20 185 275 30} box FLAT_BOX align 129
      }
      Fl_Menu_Button key_mod_a {
        label {Choose a Key Modifier}
        tooltip {These are keys like Ctrl, Alt, Shift, and Super (Windows or Apple key)} xywh {15 55 195 30} box GTK_UP_BOX
      } {
        MenuItem {} {
          label Ctrl
          callback {const char* mod = "C";
mod_cb(mod,mod1_output);}
          tooltip Control xywh {20 20 100 20}
        }
        MenuItem {} {
          label Alt
          callback {const char* mod = "A";
mod_cb(mod,mod1_output);}
          xywh {20 20 100 20}
        }
        MenuItem {} {
          label Super
          callback {const char* mod = "4";
mod_cb(mod,mod1_output);}
          xywh {20 20 100 20}
        }
        MenuItem {} {
          label Shift
          callback {const char* mod = "S";
mod_cb(mod,mod1_output);}
          xywh {20 20 100 20}
        }
      }
      Fl_Menu_Button key_mod_b {
        label {Choose a 2nd Key Modifier}
        tooltip {This is optional} xywh {15 95 230 30} box GTK_UP_BOX
      } {
        MenuItem {} {
          label Ctrl
          callback {const char* mod = "C";
mod2_cb(mod,mod2_output);}
          tooltip Control xywh {30 30 100 20}
        }
        MenuItem {} {
          label Alt
          callback {const char* mod = "A";
mod2_cb(mod,mod2_output);}
          xywh {30 30 100 20}
        }
        MenuItem {} {
          label Super
          callback {const char* mod = "4";
mod2_cb(mod,mod2_output);}
          xywh {30 30 100 20}
        }
        MenuItem {} {
          label Shift
          callback {const char* mod = "S";
mod2_cb(mod,mod2_output);}
          xywh {30 30 100 20}
        }
      }
      Fl_Input keyshortcut {
        label Key
        xywh {285 80 135 30} box FLAT_BOX when 1
      }
      Fl_Box {} {
        label OR
        xywh {165 150 25 25}
      }
      Fl_Button {} {
        label Cancel
        callback {conf_key_win->hide();}
        xywh {310 185 65 30} box FLAT_BOX color 80 selection_color 64 labelcolor 7
      }
      Fl_Output mod1_output {
        xywh {265 45 50 30} box FLAT_BOX hide
      }
      Fl_Output mod2_output {
        xywh {325 45 50 30} box FLAT_BOX hide
      }
      Fl_Output mod3_output {
        xywh {385 45 50 30} box FLAT_BOX hide
      }
      Fl_Output current_shortcut {
        label {Current Value}
        xywh {120 10 295 30} box FLAT_BOX
      }
    }
  }
  Function {add_cb()} {open
  } {
    code {flKeyboard keyboard;
std::string action = action_name->value();
if(action.compare("")==0){
  std::cout<<"No action chosen..."<<std::endl;
  return;
}
const char* this_keyInput = key_output->value();
std::string keyInput = this_keyInput;

if((action.compare("")!=0 )&& (keyInput.compare("")!=0)){
  const char* this_mod = mod_output->value();
  std::string mod = this_mod;  
  if(mod.compare("")!=0){
    keyboard.addKey(this_mod,this_keyInput,action.c_str());
  }
  else{
    keyboard.addKey(this_keyInput,action.c_str());
  }
  
  flKeyboard keyboard;
  key_browser->clear();
  keyboard.getKeys(key_browser);
  key_browser->redraw();
  grab_win->hide();
}} {}
  }
  Function {key_event()} {open
  } {
    code {//flKeyboard key;
int k = Fl::event_key();
std::string modifier_text = key->value();
std::string key_display="";
const char* event_text = Fl::event_text();
int l_shift = Fl::event_key(FL_Shift_R);
int r_shift = Fl::event_key(FL_Shift_L);
int l_control = Fl::event_key(FL_Control_R);
int r_control = Fl::event_key(FL_Control_L);
int l_meta = Fl::event_key(FL_Meta_L);
int r_meta = Fl::event_key(FL_Meta_R);
int l_alt = Fl::event_key(FL_Alt_L);
int r_alt = Fl::event_key(FL_Alt_R);
bool alt = false;
bool shift = false;
bool meta = false;
bool ctrl = false;
if(r_alt||l_alt){alt=true;
  key_display="Alt ";
  mod_cb("A");
}
if(l_shift||r_shift){
  mod_cb("S");
  key_display="Shift + ";
  shift=true;
}
if(l_control||r_control){
  key_display="Control +";
  mod_cb("C");
  ctrl=true;
}
if(l_meta||r_meta){meta=true;
  key_display="Super ";
  mod_cb("4");
}
key_display+=event_text;
const char* KEY = key_display.c_str();
std::string key_test = KEY;
if((key_test.compare("")!=0)&&(k<=256)){
  key_output->value(event_text);
  key_output->show();
  key->value(KEY);
}
  if(alt){std::cout<<"alt"<<std::endl;}
  if(shift){std::cout<<"shift"<<std::endl;}
  if(meta){std::cout<<"meta"<<std::endl;}
  if(ctrl){std::cout<<"ctrl"<<std::endl;}} {}
  }
  Function {menu_cb(const char* action)} {open
  } {
    code {action_name->value(action);} {}
  }
  Function {mod_cb(const char* mod)} {open
  } {
    code {if(mod!=NULL){mod_cb(mod,mod_output);}} {}
  }
  Function {mod2_cb(const char* mod)} {open
  } {
    code {if(mod!=NULL){mod2_cb(mod,mod_output);}} {}
  }
  Function {mod_cb(const char* mod, Fl_Output *o)} {open
  } {
    code {if(mod!=NULL){
  o->set_visible();
  o->value(mod);
}} {}
  }
  Function {mod2_cb(const char* mod, Fl_Output *o)} {open
  } {
    code {if(mod!=NULL){
  const char* test = o->value();
  if(test !=NULL){
    std::string modifier = o->value();
    std::string inputMod = mod;
    modifier += mod;
    o->value(modifier.c_str());
  }
}} {}
  }
  Function {handle(int e)} {open return_type int
  } {
    code {return (e == FL_SHORTCUT);} {}
  }
  Function {newpanel()} {open return_type bool
  } {
    code {flPanel panel;
if(panel.newStyle() == -1){return false;}
return true;} {}
  }
  Function {startup(Fl_Window *o)} {open
  } {
    code {Config config; config.under_mouse(o);
o->icon(config.Get_Fl_Icon(jsm_keyboard_xpm));} {}
  }
  Function {configure_cb()} {open
  } {
    code {std::string MOD1,MOD2,MOD3,KEY,ACTION,CURRENT;
if(mod1_output->visible()!=0){
  const char* mod1 = mod1_output->value();
  if(mod1!=NULL){
    MOD1=mod1;
    if(mod2_output->visible()!=0){
      const char* mod2 = mod2_output->value();
      if(mod2!=NULL){
        MOD2=mod2;
        if(mod3_output->visible()!=0){
          const char* mod3 = mod3_output->value();
          if(mod3!=NULL){MOD3=mod3;}
        }
      }
    }
  }
}
flKeyboard keyboard;
//std::cout<<"M1: "<<MOD1<<" M2: "<<MOD2<<" M3: "<<MOD3<<std::endl;
const char* mkey = keyshortcut->value();
if(mkey!=NULL){KEY=mkey;}
else{return;}
//std::cout<<"Keyboard: "<<mkey<<std::endl;
const char* action = action_name1->value();
if(action!=NULL){ACTION=action;}
else{return;}
//std::cout<<"Action: "<<action<<std::endl;
const char* current = current_shortcut->value();
if(current!=NULL){CURRENT=current;}
else{return;}
//std::cout<<"Current: "<<current<<std::endl;
keyboard.configureKey(CURRENT,MOD1,MOD2,MOD3,KEY,ACTION);
conf_key_win->hide();
keyboard.getKeys(key_browser);} {}
  }
  Function {key_event(Fl_Input* o, Fl_Output* out)} {open
  } {
    code {//flKeyboard key;
int k = Fl::event_key();
std::string modifier_text = o->value();
std::string key_display="";
const char* event_text = Fl::event_text();
int l_shift = Fl::event_key(FL_Shift_R);
int r_shift = Fl::event_key(FL_Shift_L);
int l_control = Fl::event_key(FL_Control_R);
int r_control = Fl::event_key(FL_Control_L);
int l_meta = Fl::event_key(FL_Meta_L);
int r_meta = Fl::event_key(FL_Meta_R);
int l_alt = Fl::event_key(FL_Alt_L);
int r_alt = Fl::event_key(FL_Alt_R);
bool alt = false;
bool shift = false;
bool meta = false;
bool ctrl = false;
if(r_alt||l_alt){alt=true;
  key_display="Alt ";
  mod_cb("A");
}
if(l_shift||r_shift){
  mod_cb("S");
  key_display="Shift + ";
  shift=true;
}
if(l_control||r_control){
  key_display="Control +";
  mod_cb("C");
  ctrl=true;
}
if(l_meta||r_meta){meta=true;
  key_display="Super ";
  mod_cb("4");
}
key_display+=event_text;
const char* KEY = key_display.c_str();
std::string key_test = KEY;
if((key_test.compare("")!=0)&&(k<=256)){
  out->value(event_text);
  out->show();
  o->value(KEY);
}
  if(alt){std::cout<<"alt"<<std::endl;}
  if(shift){std::cout<<"shift"<<std::endl;}
  if(meta){std::cout<<"meta"<<std::endl;}
  if(ctrl){std::cout<<"ctrl"<<std::endl;}} {}
  }
} 
