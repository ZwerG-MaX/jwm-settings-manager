// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include <libintl.h>
#include "desktop-file-editor.h"

void Desktop::cb_Application_i(Fl_Menu_*, void*) {
  type->value("Application");
type->redraw();
check_type();
}
void Desktop::cb_Application(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Application_i(o,v);
}

void Desktop::cb_Link_i(Fl_Menu_*, void*) {
  type->value("Link");
type->redraw();
check_type();
}
void Desktop::cb_Link(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Link_i(o,v);
}

void Desktop::cb_Directory_i(Fl_Menu_*, void*) {
  type->value("Directory");
type->redraw();
check_type();
}
void Desktop::cb_Directory(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Directory_i(o,v);
}

void Desktop::cb_OTHER_i(Fl_Menu_*, void*) {
  type->value("");
type->redraw();
check_type();
}
void Desktop::cb_OTHER(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_OTHER_i(o,v);
}

unsigned char Desktop::menu_Type_i18n_done = 0;
Fl_Menu_Item Desktop::menu_Type[] = {
 {"Application", 0,  (Fl_Callback*)Desktop::cb_Application, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Link", 0,  (Fl_Callback*)Desktop::cb_Link, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Directory", 0,  (Fl_Callback*)Desktop::cb_Directory, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"OTHER", 0,  (Fl_Callback*)Desktop::cb_OTHER, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void Desktop::cb_AudioVideo_i(Fl_Menu_*, void*) {
  categories->value("AudioVideo");
categories->redraw();
}
void Desktop::cb_AudioVideo(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_AudioVideo_i(o,v);
}

void Desktop::cb_Development_i(Fl_Menu_*, void*) {
  categories->value("Development");
categories->redraw();
}
void Desktop::cb_Development(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Development_i(o,v);
}

void Desktop::cb_Education_i(Fl_Menu_*, void*) {
  categories->value("Education");
categories->redraw();
}
void Desktop::cb_Education(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Education_i(o,v);
}

void Desktop::cb_Game_i(Fl_Menu_*, void*) {
  categories->value("Game");
categories->redraw();
}
void Desktop::cb_Game(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Game_i(o,v);
}

void Desktop::cb_Graphics_i(Fl_Menu_*, void*) {
  categories->value("Graphics");
categories->redraw();
}
void Desktop::cb_Graphics(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Graphics_i(o,v);
}

void Desktop::cb_Network_i(Fl_Menu_*, void*) {
  categories->value("Network");
categories->redraw();
}
void Desktop::cb_Network(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Network_i(o,v);
}

void Desktop::cb_Office_i(Fl_Menu_*, void*) {
  categories->value("Office");
categories->redraw();
}
void Desktop::cb_Office(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Office_i(o,v);
}

void Desktop::cb_Science_i(Fl_Menu_*, void*) {
  categories->value("Science");
categories->redraw();
}
void Desktop::cb_Science(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Science_i(o,v);
}

void Desktop::cb_Settings_i(Fl_Menu_*, void*) {
  categories->value("Settings");
categories->redraw();
}
void Desktop::cb_Settings(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Settings_i(o,v);
}

void Desktop::cb_System_i(Fl_Menu_*, void*) {
  categories->value("System");
categories->redraw();
}
void Desktop::cb_System(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_System_i(o,v);
}

void Desktop::cb_Utility_i(Fl_Menu_*, void*) {
  categories->value("Utility");
categories->redraw();
}
void Desktop::cb_Utility(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Utility_i(o,v);
}

unsigned char Desktop::menu_cat_Button_i18n_done = 0;
Fl_Menu_Item Desktop::menu_cat_Button[] = {
 {"AudioVideo", 0,  (Fl_Callback*)Desktop::cb_AudioVideo, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Development", 0,  (Fl_Callback*)Desktop::cb_Development, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Education", 0,  (Fl_Callback*)Desktop::cb_Education, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Game", 0,  (Fl_Callback*)Desktop::cb_Game, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Graphics", 0,  (Fl_Callback*)Desktop::cb_Graphics, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Network", 0,  (Fl_Callback*)Desktop::cb_Network, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Office", 0,  (Fl_Callback*)Desktop::cb_Office, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Science", 0,  (Fl_Callback*)Desktop::cb_Science, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Settings", 0,  (Fl_Callback*)Desktop::cb_Settings, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"System", 0,  (Fl_Callback*)Desktop::cb_System, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Utility", 0,  (Fl_Callback*)Desktop::cb_Utility, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void Desktop::cb_ToriOS_i(Fl_Menu_*, void*) {
  NotShowIn("ToriOS");
}
void Desktop::cb_ToriOS(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_ToriOS_i(o,v);
}

void Desktop::cb_GNOME_i(Fl_Menu_*, void*) {
  NotShowIn("GNOME");
}
void Desktop::cb_GNOME(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_GNOME_i(o,v);
}

void Desktop::cb_KDE_i(Fl_Menu_*, void*) {
  NotShowIn("KDE");
}
void Desktop::cb_KDE(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_KDE_i(o,v);
}

void Desktop::cb_LXDE_i(Fl_Menu_*, void*) {
  NotShowIn("LXDE");
}
void Desktop::cb_LXDE(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_LXDE_i(o,v);
}

void Desktop::cb_MATE_i(Fl_Menu_*, void*) {
  NotShowIn("MATE");
}
void Desktop::cb_MATE(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_MATE_i(o,v);
}

void Desktop::cb_Razor_i(Fl_Menu_*, void*) {
  NotShowIn("Razor");
}
void Desktop::cb_Razor(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Razor_i(o,v);
}

void Desktop::cb_ROX_i(Fl_Menu_*, void*) {
  NotShowIn("ROX");
}
void Desktop::cb_ROX(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_ROX_i(o,v);
}

void Desktop::cb_TDE_i(Fl_Menu_*, void*) {
  NotShowIn("TDE");
}
void Desktop::cb_TDE(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_TDE_i(o,v);
}

void Desktop::cb_Unity_i(Fl_Menu_*, void*) {
  NotShowIn("Unity");
}
void Desktop::cb_Unity(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Unity_i(o,v);
}

void Desktop::cb_XFCE_i(Fl_Menu_*, void*) {
  NotShowIn("XFCE");
}
void Desktop::cb_XFCE(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_XFCE_i(o,v);
}

void Desktop::cb_EDE_i(Fl_Menu_*, void*) {
  NotShowIn("EDE");
}
void Desktop::cb_EDE(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_EDE_i(o,v);
}

void Desktop::cb_Cinnamon_i(Fl_Menu_*, void*) {
  NotShowIn("Cinnamon");
}
void Desktop::cb_Cinnamon(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Cinnamon_i(o,v);
}

void Desktop::cb_Old_i(Fl_Menu_*, void*) {
  NotShowIn("Old");
}
void Desktop::cb_Old(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Old_i(o,v);
}

unsigned char Desktop::menu_nsi_Button_i18n_done = 0;
Fl_Menu_Item Desktop::menu_nsi_Button[] = {
 {"ToriOS", 0,  (Fl_Callback*)Desktop::cb_ToriOS, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"GNOME", 0,  (Fl_Callback*)Desktop::cb_GNOME, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"KDE", 0,  (Fl_Callback*)Desktop::cb_KDE, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"LXDE", 0,  (Fl_Callback*)Desktop::cb_LXDE, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"MATE", 0,  (Fl_Callback*)Desktop::cb_MATE, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Razor", 0,  (Fl_Callback*)Desktop::cb_Razor, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"ROX", 0,  (Fl_Callback*)Desktop::cb_ROX, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"TDE", 0,  (Fl_Callback*)Desktop::cb_TDE, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Unity", 0,  (Fl_Callback*)Desktop::cb_Unity, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"XFCE", 0,  (Fl_Callback*)Desktop::cb_XFCE, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"EDE", 0,  (Fl_Callback*)Desktop::cb_EDE, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Cinnamon", 0,  (Fl_Callback*)Desktop::cb_Cinnamon, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Old", 0,  (Fl_Callback*)Desktop::cb_Old, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void Desktop::cb_ToriOS1_i(Fl_Menu_*, void*) {
  OnlyShowIn("ToriOS");
}
void Desktop::cb_ToriOS1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_ToriOS1_i(o,v);
}

void Desktop::cb_GNOME1_i(Fl_Menu_*, void*) {
  OnlyShowIn("GNOME");
}
void Desktop::cb_GNOME1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_GNOME1_i(o,v);
}

void Desktop::cb_KDE1_i(Fl_Menu_*, void*) {
  OnlyShowIn("KDE");
}
void Desktop::cb_KDE1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_KDE1_i(o,v);
}

void Desktop::cb_LXDE1_i(Fl_Menu_*, void*) {
  OnlyShowIn("LXDE");
}
void Desktop::cb_LXDE1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_LXDE1_i(o,v);
}

void Desktop::cb_MATE1_i(Fl_Menu_*, void*) {
  OnlyShowIn("MATE");
}
void Desktop::cb_MATE1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_MATE1_i(o,v);
}

void Desktop::cb_Razor1_i(Fl_Menu_*, void*) {
  OnlyShowIn("Razor");
}
void Desktop::cb_Razor1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Razor1_i(o,v);
}

void Desktop::cb_ROX1_i(Fl_Menu_*, void*) {
  OnlyShowIn("ROX");
}
void Desktop::cb_ROX1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_ROX1_i(o,v);
}

void Desktop::cb_TDE1_i(Fl_Menu_*, void*) {
  OnlyShowIn("TDE");
}
void Desktop::cb_TDE1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_TDE1_i(o,v);
}

void Desktop::cb_Unity1_i(Fl_Menu_*, void*) {
  OnlyShowIn("Unity");
}
void Desktop::cb_Unity1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Unity1_i(o,v);
}

void Desktop::cb_XFCE1_i(Fl_Menu_*, void*) {
  OnlyShowIn("XFCE");
}
void Desktop::cb_XFCE1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_XFCE1_i(o,v);
}

void Desktop::cb_EDE1_i(Fl_Menu_*, void*) {
  OnlyShowIn("EDE");
}
void Desktop::cb_EDE1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_EDE1_i(o,v);
}

void Desktop::cb_Cinnamon1_i(Fl_Menu_*, void*) {
  OnlyShowIn("Cinnamon");
}
void Desktop::cb_Cinnamon1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Cinnamon1_i(o,v);
}

void Desktop::cb_Old1_i(Fl_Menu_*, void*) {
  OnlyShowIn("Old");
}
void Desktop::cb_Old1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Old1_i(o,v);
}

unsigned char Desktop::menu_osi_Button_i18n_done = 0;
Fl_Menu_Item Desktop::menu_osi_Button[] = {
 {"ToriOS", 0,  (Fl_Callback*)Desktop::cb_ToriOS1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"GNOME", 0,  (Fl_Callback*)Desktop::cb_GNOME1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"KDE", 0,  (Fl_Callback*)Desktop::cb_KDE1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"LXDE", 0,  (Fl_Callback*)Desktop::cb_LXDE1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"MATE", 0,  (Fl_Callback*)Desktop::cb_MATE1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Razor", 0,  (Fl_Callback*)Desktop::cb_Razor1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"ROX", 0,  (Fl_Callback*)Desktop::cb_ROX1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"TDE", 0,  (Fl_Callback*)Desktop::cb_TDE1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Unity", 0,  (Fl_Callback*)Desktop::cb_Unity1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"XFCE", 0,  (Fl_Callback*)Desktop::cb_XFCE1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"EDE", 0,  (Fl_Callback*)Desktop::cb_EDE1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Cinnamon", 0,  (Fl_Callback*)Desktop::cb_Cinnamon1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Old", 0,  (Fl_Callback*)Desktop::cb_Old1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void Desktop::cb_True_i(Fl_Menu_*, void*) {
  terminal->value("True");
terminal->redraw();
}
void Desktop::cb_True(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_True_i(o,v);
}

void Desktop::cb_False_i(Fl_Menu_*, void*) {
  terminal->value("False");
terminal->redraw();
}
void Desktop::cb_False(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_False_i(o,v);
}

unsigned char Desktop::menu_term_Button_i18n_done = 0;
Fl_Menu_Item Desktop::menu_term_Button[] = {
 {"True", 0,  (Fl_Callback*)Desktop::cb_True, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"False", 0,  (Fl_Callback*)Desktop::cb_False, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void Desktop::cb_True1_i(Fl_Menu_*, void*) {
  nodisplay->value("True");
nodisplay->redraw();
}
void Desktop::cb_True1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_True1_i(o,v);
}

void Desktop::cb_False1_i(Fl_Menu_*, void*) {
  nodisplay->value("False");
nodisplay->redraw();
}
void Desktop::cb_False1(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_False1_i(o,v);
}

unsigned char Desktop::menu_nod_Button_i18n_done = 0;
Fl_Menu_Item Desktop::menu_nod_Button[] = {
 {"True", 0,  (Fl_Callback*)Desktop::cb_True1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"False", 0,  (Fl_Callback*)Desktop::cb_False1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void Desktop::cb_icon_display_i(Fl_Button* o, void*) {
  std::string iconFILE=choose_an_icon();
if(iconFILE.compare("")!=0){
  makeWidgetIcon(iconFILE,o,48);
  o->copy_label("");
  icon->value(iconFILE.c_str());
};
}
void Desktop::cb_icon_display(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_icon_display_i(o,v);
}

void Desktop::cb_True2_i(Fl_Menu_*, void*) {
  notify->value("True");
notify->redraw();
}
void Desktop::cb_True2(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_True2_i(o,v);
}

void Desktop::cb_False2_i(Fl_Menu_*, void*) {
  notify->value("False");
notify->redraw();
}
void Desktop::cb_False2(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_False2_i(o,v);
}

unsigned char Desktop::menu_notify_Button_i18n_done = 0;
Fl_Menu_Item Desktop::menu_notify_Button[] = {
 {"True", 0,  (Fl_Callback*)Desktop::cb_True2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"False", 0,  (Fl_Callback*)Desktop::cb_False2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void Desktop::cb_True3_i(Fl_Menu_*, void*) {
  hidden->value("True");
hidden->redraw();
}
void Desktop::cb_True3(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_True3_i(o,v);
}

void Desktop::cb_False3_i(Fl_Menu_*, void*) {
  hidden->value("False");
hidden->redraw();
}
void Desktop::cb_False3(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_False3_i(o,v);
}

unsigned char Desktop::menu_Hidden_i18n_done = 0;
Fl_Menu_Item Desktop::menu_Hidden[] = {
 {"True", 0,  (Fl_Callback*)Desktop::cb_True3, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"False", 0,  (Fl_Callback*)Desktop::cb_False3, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void Desktop::cb_True4_i(Fl_Menu_*, void*) {
  dbus->value("True");
dbus->redraw();
}
void Desktop::cb_True4(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_True4_i(o,v);
}

void Desktop::cb_False4_i(Fl_Menu_*, void*) {
  dbus->value("False");
dbus->redraw();
}
void Desktop::cb_False4(Fl_Menu_* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_False4_i(o,v);
}

unsigned char Desktop::menu_DBusActivatable_i18n_done = 0;
Fl_Menu_Item Desktop::menu_DBusActivatable[] = {
 {"True", 0,  (Fl_Callback*)Desktop::cb_True4, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"False", 0,  (Fl_Callback*)Desktop::cb_False4, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void Desktop::cb_locales_browser_i(Fl_Browser* o, void*) {
  locale_chooser(CURRENT_FILE,true);
result_locale->select(o->value());
}
void Desktop::cb_locales_browser(Fl_Browser* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_locales_browser_i(o,v);
}

void Desktop::cb_result_locale_i(Fl_Browser* o, void*) {
  locales_browser->select(o->value());
locale_chooser(CURRENT_FILE,false);
locale_value->value(o->text(o->value()));
}
void Desktop::cb_result_locale(Fl_Browser* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_result_locale_i(o,v);
}

void Desktop::cb_locale_value_i(Fl_Input* o, void*) {
  result_locale->text(result_locale->value(),o->value());
}
void Desktop::cb_locale_value(Fl_Input* o, void* v) {
  ((Desktop*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_locale_value_i(o,v);
}

void Desktop::cb_OPEN_i(Fl_Button*, void*) {
  open_file();
}
void Desktop::cb_OPEN(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->parent()->user_data()))->cb_OPEN_i(o,v);
}

void Desktop::cb_save_button_i(Fl_Button*, void*) {
  check_save();
save_file();
}
void Desktop::cb_save_button(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->parent()->user_data()))->cb_save_button_i(o,v);
}

void Desktop::cb_Filename_i(Fl_Input*, void*) {
  check_save();
}
void Desktop::cb_Filename(Fl_Input* o, void* v) {
  ((Desktop*)(o->parent()->parent()->user_data()))->cb_Filename_i(o,v);
}

void Desktop::cb_CLEAR_i(Fl_Button*, void*) {
  clear_all();
}
void Desktop::cb_CLEAR(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->parent()->user_data()))->cb_CLEAR_i(o,v);
}

void Desktop::cb_PREVIEW_i(Fl_Button*, void*) {
  std::string re=stringfile();
if(re.compare("")!=0){
  preview_window(re)->show();
};
}
void Desktop::cb_PREVIEW(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->parent()->user_data()))->cb_PREVIEW_i(o,v);
}

void Desktop::cb__i(Fl_Button*, void*) {
  std::string message=gettext("Choose a Desktop File");
std::string pat="*.desktop";
const char* filer = Filename->value();
std::string fname="desktop-file-editor.desktop";
if(filer!=NULL){fname=filer;}
std::string result =nativeFileDialog(message,fname,pat);
if(result.compare("")!=0){Filename->value(result.c_str());};
}
void Desktop::cb_(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->parent()->user_data()))->cb__i(o,v);
}

#include <FL/Fl_Image.H>
static const unsigned char idata_gear16[] =
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,148,0,255,0,252,0,252,0,255,0,146,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,48,0,3,0,0,0,2,0,149,
0,255,0,255,0,255,0,255,0,147,0,2,0,0,0,2,0,24,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,20,0,151,0,218,0,79,0,0,0,2,0,149,0,255,0,255,0,255,0,255,0,147,0,1,0,0,0,
69,0,193,0,96,0,2,0,0,0,0,0,0,0,0,0,0,0,22,0,156,0,251,0,255,0,221,0,75,0,22,0,
169,0,255,0,255,0,255,0,255,0,167,0,22,0,73,0,217,0,255,0,231,0,89,0,2,0,0,0,0,
0,0,0,24,0,162,0,252,0,255,0,255,0,255,0,224,0,199,0,245,0,255,0,255,0,255,0,
255,0,245,0,200,0,225,0,255,0,255,0,255,0,228,0,85,0,2,0,0,0,0,0,46,0,212,0,255,
0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,
0,255,0,255,0,255,0,255,0,196,0,25,0,0,0,0,0,0,0,71,0,219,0,255,0,255,0,255,0,
255,0,255,0,246,0,209,0,172,0,172,0,209,0,246,0,255,0,255,0,255,0,255,0,255,0,
223,0,83,0,3,0,0,0,0,0,0,0,0,0,76,0,227,0,255,0,255,0,255,0,210,0,95,0,25,0,9,0,
10,0,25,0,95,0,210,0,255,0,255,0,255,0,225,0,77,0,1,0,0,0,0,0,2,0,2,0,0,0,23,0,
203,0,255,0,255,0,210,0,54,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,210,0,255,0,255,0,202,
0,23,0,0,0,2,0,2,0,147,0,149,0,148,0,169,0,246,0,255,0,246,0,94,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,94,0,246,0,255,0,246,0,169,0,148,0,149,0,147,0,254,0,255,
0,255,0,255,0,255,0,255,0,207,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,207,
0,255,0,255,0,255,0,255,0,255,0,254,0,252,0,255,0,255,0,255,0,255,0,255,0,170,
0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,170,0,255,0,255,0,255,0,255,0,255,0,
252,0,252,0,255,0,255,0,255,0,255,0,255,0,170,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,9,0,170,0,255,0,255,0,255,0,255,0,255,0,252,0,254,0,255,0,255,0,255,0,255,
0,255,0,207,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,207,0,255,0,255,0,255,
0,255,0,255,0,254,0,144,0,146,0,144,0,166,0,245,0,255,0,246,0,94,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,94,0,246,0,255,0,246,0,167,0,144,0,146,0,144,0,1,0,1,0,
0,0,36,0,220,0,255,0,255,0,210,0,54,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,210,0,255,
0,255,0,193,0,20,0,0,0,1,0,1,0,0,0,0,0,19,0,148,0,249,0,255,0,255,0,255,0,210,
0,95,0,25,0,9,0,10,0,25,0,95,0,210,0,255,0,255,0,255,0,187,0,26,0,0,0,0,0,0,0,
0,0,24,0,156,0,250,0,255,0,255,0,255,0,255,0,255,0,246,0,209,0,172,0,172,0,
209,0,246,0,255,0,255,0,255,0,255,0,253,0,162,0,23,0,0,0,0,0,0,0,96,0,246,0,255,
0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,0,255,
0,255,0,255,0,255,0,253,0,142,0,6,0,0,0,0,0,22,0,158,0,252,0,255,0,255,0,250,
0,183,0,191,0,246,0,255,0,255,0,255,0,255,0,244,0,218,0,247,0,255,0,255,0,255,
0,229,0,90,0,2,0,0,0,0,0,0,0,23,0,163,0,253,0,251,0,156,0,22,0,20,0,169,0,255,
0,255,0,255,0,255,0,166,0,33,0,142,0,249,0,255,0,225,0,85,0,2,0,0,0,0,0,0,0,0,
0,0,0,26,0,164,0,149,0,20,0,0,0,2,0,149,0,255,0,255,0,255,0,255,0,147,0,0,0,
16,0,149,0,216,0,80,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,13,0,0,0,0,0,2,0,
149,0,255,0,255,0,255,0,255,0,147,0,2,0,0,0,20,0,46,0,2,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,148,0,255,0,252,0,252,0,255,0,146,0,2,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0};
static Fl_RGB_Image image_gear16(idata_gear16, 24, 24, 2, 0);

void Desktop::cb_SAVE_i(Fl_Button*, void*) {
  const char* tryin=file_editor->buffer()->text();
write_out();
close(preview_win);;
}
void Desktop::cb_SAVE(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->user_data()))->cb_SAVE_i(o,v);
}

void Desktop::cb_CLOSE_i(Fl_Button*, void*) {
  close(preview_win);
}
void Desktop::cb_CLOSE(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->user_data()))->cb_CLOSE_i(o,v);
}

void Desktop::cb_OK_i(Fl_Button*, void*) {
  close(error_win);
}
void Desktop::cb_OK(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->user_data()))->cb_OK_i(o,v);
}

void Desktop::cb_1_i(Fl_Button*, void*) {
  help_window()->show();
get_help(help_browser);
}
void Desktop::cb_1(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->user_data()))->cb_1_i(o,v);
}

void Desktop::cb_CLOSE1_i(Fl_Button*, void*) {
  close(help_win);
}
void Desktop::cb_CLOSE1(Fl_Button* o, void* v) {
  ((Desktop*)(o->parent()->user_data()))->cb_CLOSE1_i(o,v);
}

Fl_Double_Window* Desktop::make_window(std::string filePassedIn) {
  Fl_Double_Window* w;
  LOCALE_STRING="aa\nab\nace\nach\naf\naf_ZA\naln\nam\nan\nar\nar_AR\nary\nas\nast\naz\nbal\nbe\nbe@latin\nbem\nbg\nbg_BG\nbn\nbn_IN\nbo\nbr\nbrx\nbs\nbyn\nca\nca_ES@valencia\nca@valencia\nce\ncgg\nchr\nckb\ncmn\nco\ncrh\ncs\ncsb\ncs_CZ\ncv\ncy\nda\nda_DK\nde\nde_CH\nde_DE\ndv\ndz\nel\nen\nen_AU\nen@boldquot\nen_CA\nen_GB\nen_NZ\nen@quot\nen@shaw\nen_US\neo\nes\nes_AR\nes_CL\nes_CO\nes_CR\nes_DO\nes_EC\nes_ES\nes_MX\nes_NI\nes_PA\nes_PE\nes_PR\nes_SV\nes_US\nes_UY\nes_VE\net\neu\neu_ES\newo\nfa\nfa_AF\nfa_IR\nff\nfi\nfi_FI\nfil\nfo\nfr\nfr_CA\nfr_FR\nfrp\nfur\nfy\nga\ngd\ngez\ngl\ngl_ES\ngu\ngv\nha\nhaw\nhe\nhe_IL\nhi\nhne\nhr\nhr_HR\nhsb\nht\nhu\nhu_HU\nhy\nia\nid\nid_ID\nig\nilo\nis\nit\nit_IT\nja\nja_JP\njv\nka\nkab\nkk\nkl\nkm\nkm_KH\nkn\nko\nkok\nko_KR\nks\nks_IN\nku\nku_IQ\nkw\nky\nla\nlb\nlg\nli\nln\nlo\nlo_LA\nlt\nlt_LT\nlv\nlv_LV\nmai\nmg\nmhr\nmi\nmk\nmk_MK\nml\nml_IN\nmn\nmr\nms\nms_MY\nmt\nmy\nnah\nnb\nnb_NO\nnds\nne\nnhn\nnl\nnl_NL\nnn\nnn_NO\nno\nnqo\nnso\noc\nom\nor\nos\npa\npam\npl\npl_PL\nps\npt\npt_BR\npt_PT\nqu\nrm\nro\nro_RO\nru\nru_RU\nrw\nsa\nsc\nsco\nsd\nse\nshn\nsi\nsk\nsk_SK\nsl\nsl_SI\nsma\nsml\nsn\nso\nsq\nsr\nsr@cyrillic\nsr@ijekavian\nsr@ijekavianlatin\nsr@latin\nsr@Latn\nsr_RS\nsr_RS@latin\nst\nsv\nsw\nszl\nta\nta_IN\nta_LK\nte\ntet\ntg\nth\nth_TH\nti\ntig\ntk\ntl\ntr\ntrv\nts\ntt\ntt@iqtelif\ntt_RU\nug\nuk\nuk_UA\nur\nur_PK\nuz\nuz@cyrillic\nuz@Latn\nve\nvec\nvi\nvi_VN\nwa\nwae\nwal\nwo\nxh\nyi\nyo\nzh_CN\nzh_HK\nzh_TW\nzu";
  CURRENT_FILE=filePassedIn;
  { Fl_Double_Window* o = new Fl_Double_Window(410, 570, gettext("Desktop File Editor"));
    w = o;
    o->color(FL_DARK1);
    o->user_data((void*)(this));
    { Fl_Scroll* o = new Fl_Scroll(0, 0, 415, 563);
      { Fl_Tabs* o = new Fl_Tabs(5, 5, 410, 460);
        o->box(FL_FLAT_BOX);
        o->color(FL_DARK1);
        { Fl_Group* o = new Fl_Group(5, 30, 402, 430, gettext("Normal"));
          o->box(FL_FLAT_BOX);
          o->selection_color(FL_DARK2);
          { name = new Fl_Input(145, 50, 255, 30, gettext("Name"));
            name->tooltip(gettext("Specific name of the application, for example \"Mozilla\"."));
            name->box(FL_FLAT_BOX);
            name->labelfont(1);
          } // Fl_Input* name
          { comment = new Fl_Input(145, 86, 255, 31, gettext("Comment"));
            comment->tooltip(gettext("Tooltip for the entry, for example \"View sites on the Internet\". The value \
should not be redundant with the values of Name and GenericName."));
            comment->box(FL_FLAT_BOX);
          } // Fl_Input* comment
          { tryexec = new Fl_Input(145, 123, 255, 30, gettext("TryExec"));
            tryexec->tooltip(gettext("Path to an executable file on disk used to determine if the program is actual\
ly installed. If the path is not an absolute path, the file is looked up in th\
e $PATH environment variable. If the file is not present or if it is not execu\
table, the entry may be ignored (not be used in menus, for example)."));
            tryexec->box(FL_FLAT_BOX);
          } // Fl_Input* tryexec
          { exec = new Fl_Input(145, 159, 255, 30, gettext("Exec"));
            exec->tooltip(gettext("Program to execute, possibly with arguments. See the Exec key for details on \
how this key works. The Exec key is required if DBusActivatable is not set to \
true. Even if DBusActivatable is true, Exec should be specified for compatibil\
ity with implementations that do not understand DBusActivatable."));
            exec->box(FL_FLAT_BOX);
          } // Fl_Input* exec
          { icon = new Fl_Input(145, 196, 255, 30, gettext("Icon"));
            icon->tooltip(gettext("Icon to display in file manager, menus, etc. If the name is an absolute path,\
 the given file will be used. If the name is not an absolute path, the algorit\
hm described in the Icon Theme Specification will be used to locate the icon."));
            icon->box(FL_FLAT_BOX);
          } // Fl_Input* icon
          { type = new Fl_Input(145, 232, 255, 30);
            type->tooltip(gettext("This specification defines 3 types of desktop entries: Application (type 1), \
Link (type 2) and Directory (type 3). To allow the addition of new types in th\
e future, implementations should ignore desktop entries with an unknown type"));
            type->box(FL_FLAT_BOX);
          } // Fl_Input* type
          { categories = new Fl_Input(145, 269, 255, 30);
            categories->tooltip(gettext("Categories in which the entry should be shown in a menu (for possible values \
see the Desktop Menu Specification)."));
            categories->box(FL_FLAT_BOX);
          } // Fl_Input* categories
          { notshowin = new Fl_Input(145, 305, 255, 30);
            notshowin->tooltip(gettext("A list of strings identifying the desktop environments that should display/no\
t display a given desktop entry.\n\nBy default, a desktop file should be shown\
, unless an OnlyShowIn key is present, in which case, the default is for the f\
ile not to be shown.\n\nIf $XDG_CURRENT_DESKTOP is set then it contains a colo\
n-separated list of strings. In order, each string is considered. If a matchin\
g entry is found in OnlyShowIn then the desktop file is shown. If an entry is \
found in NotShowIn then the desktop file is not shown. If none of the strings \
match then the default action is taken (as above).\n\nThe same desktop name ma\
y not appear in both OnlyShowIn and NotShowIn of a group."));
            notshowin->box(FL_FLAT_BOX);
          } // Fl_Input* notshowin
          { onlyshowin = new Fl_Input(145, 342, 255, 30);
            onlyshowin->tooltip(gettext("A list of strings identifying the desktop environments that should display/no\
t display a given desktop entry.\n\nBy default, a desktop file should be shown\
, unless an OnlyShowIn key is present, in which case, the default is for the f\
ile not to be shown.\n\nIf $XDG_CURRENT_DESKTOP is set then it contains a colo\
n-separated list of strings. In order, each string is considered. If a matchin\
g entry is found in OnlyShowIn then the desktop file is shown. If an entry is \
found in NotShowIn then the desktop file is not shown. If none of the strings \
match then the default action is taken (as above).\n\nThe same desktop name ma\
y not appear in both OnlyShowIn and NotShowIn of a group."));
            onlyshowin->box(FL_FLAT_BOX);
          } // Fl_Input* onlyshowin
          { terminal = new Fl_Input(145, 378, 255, 30);
            terminal->tooltip(gettext("Whether the program runs in a terminal window."));
            terminal->box(FL_FLAT_BOX);
          } // Fl_Input* terminal
          { nodisplay = new Fl_Input(145, 415, 255, 30);
            nodisplay->tooltip(gettext("NoDisplay means \"this application exists, but don\'t display it in the menus\
\". This can be useful to e.g. associate this application with MIME types, so \
that it gets launched from a file manager (or other apps), without having a me\
nu entry for it (there are tons of good reasons for this, including e.g. the n\
etscape -remote, or kfmclient openURL kind of stuff)."));
            nodisplay->box(FL_FLAT_BOX);
          } // Fl_Input* nodisplay
          { Fl_Menu_Button* o = new Fl_Menu_Button(15, 232, 120, 30, gettext("Type"));
            o->tooltip(gettext("This specification defines 3 types of desktop entries: Application (type 1), \
Link (type 2) and Directory (type 3). To allow the addition of new types in th\
e future, implementations should ignore desktop entries with an unknown type."));
            o->box(FL_FLAT_BOX);
            o->down_box(FL_FLAT_BOX);
            o->color((Fl_Color)23);
            o->selection_color((Fl_Color)37);
            o->labelfont(1);
            if (!menu_Type_i18n_done) {
              int i=0;
              for ( ; i<4; i++)
                if (menu_Type[i].label())
                  menu_Type[i].label(gettext(menu_Type[i].label()));
              menu_Type_i18n_done = 1;
            }
            o->menu(menu_Type);
          } // Fl_Menu_Button* o
          { cat_Button = new Fl_Menu_Button(15, 269, 120, 30, gettext("Categories"));
            cat_Button->tooltip(gettext("Categories in which the entry should be shown in a menu (for possible values \
see the Desktop Menu Specification)."));
            cat_Button->box(FL_FLAT_BOX);
            cat_Button->down_box(FL_FLAT_BOX);
            cat_Button->color((Fl_Color)23);
            cat_Button->selection_color((Fl_Color)37);
            if (!menu_cat_Button_i18n_done) {
              int i=0;
              for ( ; i<11; i++)
                if (menu_cat_Button[i].label())
                  menu_cat_Button[i].label(gettext(menu_cat_Button[i].label()));
              menu_cat_Button_i18n_done = 1;
            }
            cat_Button->menu(menu_cat_Button);
          } // Fl_Menu_Button* cat_Button
          { nsi_Button = new Fl_Menu_Button(15, 305, 120, 30, gettext("NotShowIn"));
            nsi_Button->tooltip(gettext("A list of strings identifying the desktop environments that should display/no\
t display a given desktop entry.\n\nBy default, a desktop file should be shown\
, unless an OnlyShowIn key is present, in which case, the default is for the f\
ile not to be shown.\n\nIf $XDG_CURRENT_DESKTOP is set then it contains a colo\
n-separated list of strings. In order, each string is considered. If a matchin\
g entry is found in OnlyShowIn then the desktop file is shown. If an entry is \
found in NotShowIn then the desktop file is not shown. If none of the strings \
match then the default action is taken (as above).\n\nThe same desktop name ma\
y not appear in both OnlyShowIn and NotShowIn of a group."));
            nsi_Button->box(FL_FLAT_BOX);
            nsi_Button->down_box(FL_FLAT_BOX);
            nsi_Button->color((Fl_Color)23);
            nsi_Button->selection_color((Fl_Color)37);
            if (!menu_nsi_Button_i18n_done) {
              int i=0;
              for ( ; i<13; i++)
                if (menu_nsi_Button[i].label())
                  menu_nsi_Button[i].label(gettext(menu_nsi_Button[i].label()));
              menu_nsi_Button_i18n_done = 1;
            }
            nsi_Button->menu(menu_nsi_Button);
          } // Fl_Menu_Button* nsi_Button
          { osi_Button = new Fl_Menu_Button(15, 342, 120, 30, gettext("OnlyShowIn"));
            osi_Button->tooltip(gettext("A list of strings identifying the desktop environments that should display/no\
t display a given desktop entry.\n\nBy default, a desktop file should be shown\
, unless an OnlyShowIn key is present, in which case, the default is for the f\
ile not to be shown.\n\nIf $XDG_CURRENT_DESKTOP is set then it contains a colo\
n-separated list of strings. In order, each string is considered. If a matchin\
g entry is found in OnlyShowIn then the desktop file is shown. If an entry is \
found in NotShowIn then the desktop file is not shown. If none of the strings \
match then the default action is taken (as above).\n\nThe same desktop name ma\
y not appear in both OnlyShowIn and NotShowIn of a group."));
            osi_Button->box(FL_FLAT_BOX);
            osi_Button->down_box(FL_FLAT_BOX);
            osi_Button->color((Fl_Color)23);
            osi_Button->selection_color((Fl_Color)37);
            if (!menu_osi_Button_i18n_done) {
              int i=0;
              for ( ; i<13; i++)
                if (menu_osi_Button[i].label())
                  menu_osi_Button[i].label(gettext(menu_osi_Button[i].label()));
              menu_osi_Button_i18n_done = 1;
            }
            osi_Button->menu(menu_osi_Button);
          } // Fl_Menu_Button* osi_Button
          { term_Button = new Fl_Menu_Button(15, 378, 120, 30, gettext("Terminal"));
            term_Button->tooltip(gettext("Whether the program runs in a terminal window."));
            term_Button->box(FL_FLAT_BOX);
            term_Button->down_box(FL_FLAT_BOX);
            term_Button->color((Fl_Color)23);
            term_Button->selection_color((Fl_Color)37);
            if (!menu_term_Button_i18n_done) {
              int i=0;
              for ( ; i<2; i++)
                if (menu_term_Button[i].label())
                  menu_term_Button[i].label(gettext(menu_term_Button[i].label()));
              menu_term_Button_i18n_done = 1;
            }
            term_Button->menu(menu_term_Button);
          } // Fl_Menu_Button* term_Button
          { nod_Button = new Fl_Menu_Button(15, 415, 120, 30, gettext("NoDisplay"));
            nod_Button->tooltip(gettext("NoDisplay means \"this application exists, but don\'t display it in the menus\
\". This can be useful to e.g. associate this application with MIME types, so \
that it gets launched from a file manager (or other apps), without having a me\
nu entry for it (there are tons of good reasons for this, including e.g. the n\
etscape -remote, or kfmclient openURL kind of stuff)."));
            nod_Button->box(FL_FLAT_BOX);
            nod_Button->down_box(FL_FLAT_BOX);
            nod_Button->color((Fl_Color)23);
            nod_Button->selection_color((Fl_Color)37);
            if (!menu_nod_Button_i18n_done) {
              int i=0;
              for ( ; i<2; i++)
                if (menu_nod_Button[i].label())
                  menu_nod_Button[i].label(gettext(menu_nod_Button[i].label()));
              menu_nod_Button_i18n_done = 1;
            }
            nod_Button->menu(menu_nod_Button);
          } // Fl_Menu_Button* nod_Button
          { icon_display = new Fl_Button(35, 160, 65, 65, gettext("ICON"));
            icon_display->box(FL_FLAT_BOX);
            icon_display->color((Fl_Color)23);
            icon_display->labelfont(1);
            icon_display->callback((Fl_Callback*)cb_icon_display);
            icon_display->align(Fl_Align(512));
          } // Fl_Button* icon_display
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(10, 30, 395, 430, gettext("Advanced"));
          o->box(FL_FLAT_BOX);
          o->selection_color(FL_DARK2);
          o->hide();
          { genericname = new Fl_Input(145, 40, 255, 30, gettext("GenericName"));
            genericname->tooltip(gettext("Generic name of the application, for example \"Web Browser\"."));
            genericname->box(FL_FLAT_BOX);
          } // Fl_Input* genericname
          { version = new Fl_Input(145, 75, 255, 30, gettext("Version"));
            version->tooltip(gettext("Version of the Desktop Entry Specification that the desktop entry conforms wi\
th. Entries that confirm with this version of the specification should use 1.0\
. Note that the version field is not required to be present."));
            version->box(FL_FLAT_BOX);
          } // Fl_Input* version
          { path = new Fl_Input(145, 110, 255, 30, gettext("Path"));
            path->tooltip(gettext("If entry is of type Application, the working directory to run the program in."));
            path->box(FL_FLAT_BOX);
          } // Fl_Input* path
          { mime = new Fl_Input(145, 145, 255, 30, gettext("MimeType"));
            mime->tooltip(gettext("The MIME type(s) supported by this application."));
            mime->box(FL_FLAT_BOX);
          } // Fl_Input* mime
          { implements = new Fl_Input(145, 180, 255, 30, gettext("Implements"));
            implements->tooltip(gettext("A list of interfaces that this application implements. By default, a desktop \
file implements no interfaces. See http://standards.freedesktop.org/desktop-en\
try-spec/latest/ar01s08.html for more information on how this works."));
            implements->box(FL_FLAT_BOX);
          } // Fl_Input* implements
          { keywords = new Fl_Input(145, 215, 255, 30, gettext("Keywords"));
            keywords->tooltip(gettext("A list of strings which may be used in addition to other metadata to describe\
 this entry. This can be useful e.g. to facilitate searching through entries. \
The values are not meant for display, and should not be redundant with the val\
ues of Name or GenericName."));
            keywords->box(FL_FLAT_BOX);
          } // Fl_Input* keywords
          { wmclass = new Fl_Input(145, 250, 255, 30, gettext("StartupWMClass"));
            wmclass->tooltip(gettext("If specified, it is known that the application will map at least one window w\
ith the given string as its WM class or WM name hint (see the Startup Notifica\
tion Protocol Specification for more details)."));
            wmclass->box(FL_FLAT_BOX);
          } // Fl_Input* wmclass
          { url = new Fl_Input(145, 285, 255, 30, gettext("URL"));
            url->tooltip(gettext("If entry is Link type, the URL to access."));
            url->box(FL_FLAT_BOX);
            url->labelfont(1);
          } // Fl_Input* url
          { actions = new Fl_Input(145, 320, 255, 30);
            actions->tooltip(gettext("Identifiers for application actions. This can be used to tell the application\
 to make a specific action, different from the default behavior. The Applicati\
on actions section describes how actions work."));
            actions->box(FL_FLAT_BOX);
            actions->deactivate();
          } // Fl_Input* actions
          { notify = new Fl_Input(145, 355, 255, 30);
            notify->tooltip(gettext("If true, it is KNOWN that the application will send a \"remove\" message when\
 started with the DESKTOP_STARTUP_ID environment variable set. If false, it is\
 KNOWN that the application does not work with startup notification at all (do\
es not shown any window, breaks even when using StartupWMClass, etc.). If abse\
nt, a reasonable handling is up to implementations (assuming false, using Star\
tupWMClass, etc.). (See the Startup Notification Protocol Specification for mo\
re details)."));
            notify->box(FL_FLAT_BOX);
          } // Fl_Input* notify
          { hidden = new Fl_Input(145, 390, 255, 30);
            hidden->tooltip(gettext("Hidden should have been called Deleted. It means the user deleted (at his lev\
el) something that was present (at an upper level, e.g. in the system dirs). I\
t\'s strictly equivalent to the .desktop file not existing at all, as far as t\
hat user is concerned. This can also be used to \"uninstall\" existing files (\
e.g. due to a renaming) - by letting make install install a file with Hidden=t\
rue in it."));
            hidden->box(FL_FLAT_BOX);
          } // Fl_Input* hidden
          { dbus = new Fl_Input(145, 425, 255, 30);
            dbus->tooltip(gettext("A boolean value specifying if D-Bus activation is supported for this applicat\
ion. If this key is missing, the default value is false. If the value is true \
then implementations should ignore the Exec key and send a D-Bus message to la\
unch the application. See D-Bus Activation for more information on how this wo\
rks. Applications should still include Exec= lines in their desktop files for \
compatibility with implementations that do not understand the DBusActivatable \
key."));
            dbus->box(FL_FLAT_BOX);
          } // Fl_Input* dbus
          { Fl_Button* o = new Fl_Button(10, 320, 130, 30, gettext("Actions"));
            o->tooltip(gettext("Identifiers for application actions. This can be used to tell the application\
 to make a specific action, different from the default behavior. The Applicati\
on actions section describes how actions work."));
            o->box(FL_FLAT_BOX);
            o->color((Fl_Color)23);
            o->deactivate();
          } // Fl_Button* o
          { notify_Button = new Fl_Menu_Button(10, 355, 130, 30, gettext("StartupNotify"));
            notify_Button->tooltip(gettext("If true, it is KNOWN that the application will send a \"remove\" message when\
 started with the DESKTOP_STARTUP_ID environment variable set. If false, it is\
 KNOWN that the application does not work with startup notification at all (do\
es not shown any window, breaks even when using StartupWMClass, etc.). If abse\
nt, a reasonable handling is up to implementations (assuming false, using Star\
tupWMClass, etc.). (See the Startup Notification Protocol Specification for mo\
re details)."));
            notify_Button->box(FL_FLAT_BOX);
            notify_Button->down_box(FL_FLAT_BOX);
            notify_Button->color((Fl_Color)23);
            notify_Button->selection_color((Fl_Color)37);
            if (!menu_notify_Button_i18n_done) {
              int i=0;
              for ( ; i<2; i++)
                if (menu_notify_Button[i].label())
                  menu_notify_Button[i].label(gettext(menu_notify_Button[i].label()));
              menu_notify_Button_i18n_done = 1;
            }
            notify_Button->menu(menu_notify_Button);
          } // Fl_Menu_Button* notify_Button
          { Fl_Menu_Button* o = new Fl_Menu_Button(10, 390, 130, 30, gettext("Hidden"));
            o->tooltip(gettext("Hidden should have been called Deleted. It means the user deleted (at his lev\
el) something that was present (at an upper level, e.g. in the system dirs). I\
t\'s strictly equivalent to the .desktop file not existing at all, as far as t\
hat user is concerned. This can also be used to \"uninstall\" existing files (\
e.g. due to a renaming) - by letting make install install a file with Hidden=t\
rue in it."));
            o->box(FL_FLAT_BOX);
            o->down_box(FL_FLAT_BOX);
            o->color((Fl_Color)23);
            o->selection_color((Fl_Color)37);
            if (!menu_Hidden_i18n_done) {
              int i=0;
              for ( ; i<2; i++)
                if (menu_Hidden[i].label())
                  menu_Hidden[i].label(gettext(menu_Hidden[i].label()));
              menu_Hidden_i18n_done = 1;
            }
            o->menu(menu_Hidden);
          } // Fl_Menu_Button* o
          { Fl_Menu_Button* o = new Fl_Menu_Button(10, 425, 130, 30, gettext("DBusActivatable"));
            o->tooltip(gettext("A boolean value specifying if D-Bus activation is supported for this applicat\
ion. If this key is missing, the default value is false. If the value is true \
then implementations should ignore the Exec key and send a D-Bus message to la\
unch the application. See D-Bus Activation for more information on how this wo\
rks. Applications should still include Exec= lines in their desktop files for \
compatibility with implementations that do not understand the DBusActivatable \
key."));
            o->box(FL_FLAT_BOX);
            o->down_box(FL_FLAT_BOX);
            o->color((Fl_Color)23);
            o->selection_color((Fl_Color)37);
            if (!menu_DBusActivatable_i18n_done) {
              int i=0;
              for ( ; i<2; i++)
                if (menu_DBusActivatable[i].label())
                  menu_DBusActivatable[i].label(gettext(menu_DBusActivatable[i].label()));
              menu_DBusActivatable_i18n_done = 1;
            }
            o->menu(menu_DBusActivatable);
          } // Fl_Menu_Button* o
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(5, 35, 395, 427, gettext("Locale"));
          o->tooltip(gettext("Configure Locale specific Names"));
          o->selection_color(FL_DARK2);
          o->hide();
          { Fl_Browser* o = locales_browser = new Fl_Browser(10, 35, 120, 390);
            locales_browser->type(2);
            locales_browser->box(FL_FLAT_BOX);
            locales_browser->selection_color(FL_DARK_RED);
            locales_browser->callback((Fl_Callback*)cb_locales_browser);
            locales_browser->when(3);
            populateBrowserWithString(o,LOCALE_STRING);
          } // Fl_Browser* locales_browser
          { Fl_Browser* o = result_locale = new Fl_Browser(135, 35, 260, 390);
            result_locale->type(2);
            result_locale->box(FL_FLAT_BOX);
            result_locale->selection_color(FL_DARK_RED);
            result_locale->callback((Fl_Callback*)cb_result_locale);
            populate_locales(o,CURRENT_FILE);
          } // Fl_Browser* result_locale
          { locale_value = new Fl_Input(65, 429, 330, 33);
            locale_value->tooltip(gettext("Change Locale text"));
            locale_value->box(FL_FLAT_BOX);
            locale_value->selection_color((Fl_Color)80);
            locale_value->callback((Fl_Callback*)cb_locale_value);
            locale_value->when(3);
          } // Fl_Input* locale_value
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(5, 40, 401, 425, gettext("Extra Actions"));
          o->tooltip(gettext("Configure extra Actions"));
          o->selection_color(FL_DARK2);
          o->hide();
          o->deactivate();
          { Fl_Box* o = new Fl_Box(145, 160, 85, 40, gettext("TODO!"));
            o->labelfont(1);
          } // Fl_Box* o
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Tabs* o
      { Fl_Button* o = new Fl_Button(15, 530, 80, 30, gettext("OPEN"));
        o->tooltip(gettext("Open a desktop file"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_OPEN);
      } // Fl_Button* o
      { save_button = new Fl_Button(320, 530, 80, 30, gettext("SAVE"));
        save_button->tooltip(gettext("Save the current data as a file"));
        save_button->box(FL_FLAT_BOX);
        save_button->color((Fl_Color)61);
        save_button->selection_color((Fl_Color)59);
        save_button->labelcolor(FL_BACKGROUND2_COLOR);
        save_button->callback((Fl_Callback*)cb_save_button);
      } // Fl_Button* save_button
      { Filename = new Fl_Input(50, 475, 350, 30);
        Filename->tooltip(gettext("The file you want to save (or the name of the current open file)"));
        Filename->box(FL_FLAT_BOX);
        Filename->callback((Fl_Callback*)cb_Filename);
        Filename->when(3);
      } // Fl_Input* Filename
      { Fl_Button* o = new Fl_Button(220, 530, 80, 30, gettext("CLEAR"));
        o->tooltip(gettext("CLEAR EVERYTHING"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)80);
        o->selection_color(FL_DARK_RED);
        o->labelcolor(FL_BACKGROUND2_COLOR);
        o->callback((Fl_Callback*)cb_CLEAR);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(115, 530, 80, 30, gettext("PREVIEW"));
        o->tooltip(gettext("Preview text"));
        o->box(FL_FLAT_BOX);
        o->color(FL_YELLOW);
        o->selection_color((Fl_Color)94);
        o->labelcolor(FL_GRAY0);
        o->callback((Fl_Callback*)cb_PREVIEW);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(10, 475, 35, 30);
        o->tooltip(gettext("Open a desktop file"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->image(image_gear16);
        o->callback((Fl_Callback*)cb_);
      } // Fl_Button* o
      o->end();
    } // Fl_Scroll* o
    load(filePassedIn);
    o->xclass("desktop-file-editor");
    o->end();
  } // Fl_Double_Window* o
  return w;
}

Fl_Double_Window* Desktop::preview_window(std::string message) {
  { preview_win = new Fl_Double_Window(465, 465, gettext("Preview"));
    preview_win->user_data((void*)(this));
    { Fl_Scroll* o = new Fl_Scroll(10, 5, 440, 410);
      { Fl_Text_Editor* o = file_editor = new Fl_Text_Editor(10, 5, 440, 410);
        file_editor->box(FL_FLAT_BOX);
        preview_text(o,message);
      } // Fl_Text_Editor* file_editor
      o->end();
    } // Fl_Scroll* o
    { Fl_Button* o = new Fl_Button(365, 425, 80, 30, gettext("SAVE"));
      o->tooltip(gettext("Save the current data as a file"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)61);
      o->selection_color((Fl_Color)58);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_SAVE);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(275, 425, 80, 30, gettext("CLOSE"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->selection_color(FL_DARK_RED);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_CLOSE);
    } // Fl_Button* o
    preview_win->end();
  } // Fl_Double_Window* preview_win
  return preview_win;
}

void Desktop::activate(Fl_Input* o) {
  o->activate();
  o->color(FL_WHITE);
}

void Desktop::activate(Fl_Menu_Button* o) {
  o->activate();
}

void Desktop::check_type() {
  if(isEmpty(type)){show_all();return;}
  activate(type);
  std::string TYPE=type->value();
  if(TYPE.compare("Application")==0){
    show_apps_only();
  }
  else if(TYPE.compare("Directory")==0){
    show_dir_only();
  }
  else if(TYPE.compare("Link")==0){
    show_link_only();
  }
  else{
    show_all();
  }
}

std::string Desktop::choose_directory() {
  std::string message=gettext("Choose a Directory");
  const char* fname=getenv("PWD");
  if (fname == NULL){
    fname=getenv("XDG_CONFIG_HOME");
    if (fname == NULL){fname=getenv("HOME");}
    else{
      std::string autostart=fname;
      autostart+="/autostart/";
      fname=autostart.c_str();
    }
  }
  std::string RESULT=choose_a_directory(fname,message);
  return RESULT;
}

void Desktop::clear_all() {
  //normal
  clear_input(name);
  clear_input(exec);
  clear_input(tryexec);
  clear_input(comment);
  clear_input(icon);
  clear_input(type);
  clear_input(categories);
  clear_input(notshowin);
  clear_input(onlyshowin);
  clear_input(terminal);
  clear_input(nodisplay);
  //advanced
  clear_input(genericname);
  clear_input(version);
  clear_input(path);
  clear_input(mime);
  clear_input(implements);
  clear_input(keywords);
  clear_input(wmclass);
  clear_input(url);
  clear_input(actions);
  clear_input(notify);
  clear_input(hidden);
  clear_input(dbus);
  clear_input(Filename);
  show_all();
}

void Desktop::clear_input(Fl_Input *o) {
  o->value("");
  o->redraw();
}

void Desktop::close(Fl_Double_Window* o) {
  o->hide();
}

void Desktop::DEactivate(Fl_Input* o) {
  o->deactivate();
  o->color(FL_LIGHT2);
  o->value("");
}

void Desktop::DEactivate(Fl_Menu_Button* o) {
  o->deactivate();
}

std::string Desktop::get_line(std::string filename, std::string line) {
  std::string thisLine = linuxcommon::get_line_with_equal(filename,line);
  return thisLine;
}

bool Desktop::isEmpty(Fl_Input *o) {
  const char* charVal= o->value();
  if ( charVal == NULL){
    make_red(o);
    return true;
  }
  std::string STRINGval=o->value();
  if (STRINGval.compare("")==0){
    make_red(o);
    return true;
  }
  make_white(o);
  return false;
}

std::string Desktop::keyWords(std::string filename) {
  std::string GenericName = get_line("GenericName=",filename);
  std::string Keywords = get_line("Keywords=",filename);
  std::string result;
  if(GenericName.compare("")!=0){result=GenericName;}
  if(Keywords.compare("")!=0){result+=Keywords;}
  if(result.compare("")==0){result="none";}
  return result;
}

void Desktop::load(std::string result) {
  if(result.compare("")!=0){
    std::string tmp=linuxcommon::process_filename(result);
    result=tmp;
    std::cout<<"POST PROCESSED FILE="<<result<<std::endl;
    populate(result);
    Filename->value(tmp.c_str());
    if(!linuxcommon::file_is_writable(result)){save_button->deactivate();}
    else{save_button->activate();}
  }
  check_type();
  check_save();
}

void Desktop::locale_chooser(std::string filename, bool getval) {
  std::string tmp="";
  if(getval){
    tmp=name_locale_line(filename,locales_browser);
  }
  locale_value->copy_label("                 ");
  locale_value->copy_label(locales_browser->text(locales_browser->value()));
  locale_value->value(tmp.c_str());
  if(tmp.compare("")!=0){
    result_locale->text(locales_browser->value(),tmp.c_str());
    result_locale->redraw();
  }
}

void Desktop::make_red(Fl_Input *o) {
  o->color(FL_RED);
  o->redraw();
}

void Desktop::make_white(Fl_Input *o) {
  o->color(FL_WHITE);
  o->redraw();
}

bool Desktop::not_showin(std::string filename) {
  char* desktop = getenv("XDG_CURRENT_DESKTOP");
  char* desktop_session = getenv("DESKTOP_SESSION");
  std::string result = get_line("NotShowIn=",filename);
  unsigned int found = 0;
  if(result.compare("")==0){
    return false;
  }
  std::transform(result.begin(),result.end(),result.begin(),::tolower);
  std::string temp1,temp2;
  temp2=result;
  for(unsigned int i = 0; i<result.length();i++){
    found = temp2.find_first_of(';');
    if(found < temp2.length()){
      temp2=temp2.erase(found,temp2.length());
      temp1 = result.erase(0,found+1);
    if (desktop !=NULL){
      //std::cout<<"desktop: "<<desktop<<"\nresult: "<<temp2<<std::endl;
      if (temp2.compare(desktop)==0){
      return true;
      }
    }
    if (desktop_session !=NULL){
      //std::cout<<"desktop session: "<<desktop_session<<"\nresult: "<<temp2<<std::endl;
      if (temp2.compare(desktop_session)==0){
      return true;
      }
    }
      temp2=temp1;
    }
  }
  return false;
}

std::string Desktop::name_line(std::string filename) {
  std::string base_lang,result,strlang,strlanguage,startbase,NAME,LOCALNAME,LOCALEND;
  NAME="Name";
  LOCALNAME="Name[";
  LOCALEND="]=";
  unsigned int underscore = 0;
  char* lang = getenv("LANG");
  char* language = getenv("LANGUAGE");
  if(lang!=NULL)strlang = lang;
  if(language!=NULL)strlanguage =language;
  if (strlanguage.compare("")!=0){  
    result=get_line(filename, (LOCALNAME+ strlanguage + LOCALEND));
    if(result.compare("")!=0){return result;}
    base_lang=strlanguage;
  }
  else{
    if (strlang.compare("")!=0){
        unsigned int dot = 0;
        dot=strlang.find('.');
        if(dot<strlang.length())
          startbase=strlang.erase(dot,strlang.length());
        result=get_line(filename, (LOCALNAME+ startbase + LOCALEND));
        if(result.compare("")!=0){return result;}
        base_lang=startbase;
     }
     else{return get_line(filename,"Name=");}
  }
  underscore=base_lang.find('_');
  if(underscore<base_lang.length())
    base_lang=base_lang.erase(underscore,base_lang.length());
  result=get_line( filename,(LOCALNAME+ base_lang + LOCALEND));
  if(result.compare("")!=0){return result;}
  return get_line(filename,"Name=");
}

std::string Desktop::name_locale_line(std::string filename,Fl_Browser *o) {
  //errorOUT(filename);
  if(!checkFlBrowserItem(o)){return "";}
  std::string LANG=o->text(o->value());
  return no_browser_name_locale(filename,LANG);
}

std::string Desktop::no_browser_name_locale(std::string filename, std::string LANG) {
  std::string result,LOCALNAME,LOCALEND;
  LOCALNAME="Name[";
  LOCALEND="]=";
  std::string testing=LOCALNAME+ LANG + LOCALEND;
  result=get_line(filename, testing);
  //errorOUT(testing+" "+result);
  if(result.compare("")!=0){return result;}
  else{
    testing=LOCALNAME+ LANG;
    result=get_line(filename, testing);
    //errorOUT(testing+" "+result);
    if(result.compare("")!=0){return result;}
  }
  return "";
}

bool Desktop::no_display(std::string filename) {
  std::string result = get_line(filename,"NoDisplay=");
  if(result.compare("")==0){
    return false;
  }
  std::transform(result.begin(),result.end(),result.begin(),::tolower);
  if (result.compare("true")==0){return true;}
  else{return false;}
  
  return false;
}

void Desktop::NotShowIn(const char* DE) {
  if(DE==NULL){return;}
  if(!isEmpty(onlyshowin)){
    std::string ONLY = onlyshowin->value();
    unsigned int finder = 0;
    finder=ONLY.find(DE);
    if(finder<ONLY.length()){
      make_red(onlyshowin);
      make_red(notshowin);
      return;
    }
  }
  notshowin->value(DE);
  notshowin->redraw();
}

bool Desktop::only_show(std::string filename) {
  char* desktop = getenv("XDG_CURRENT_DESKTOP");
  char* desktop_session = getenv("DESKTOP_SESSION");
  std::string result = get_line("OnlyShowIn=",filename);
  unsigned int found = 0;
  if(result.compare("")==0){
  //Only show in line doesn't exist
    return true;
  }
  //std::cout<<"OnlyShowIn="<<result<<std::endl;
  //compare lower case words only
  std::transform(result.begin(),result.end(),result.begin(),::tolower);
  
  std::string temp1,temp2;
  temp2=result;
  
  for(unsigned int i = 0; i<result.length();i++){
    found = temp2.find_first_of(';');
    if(found < temp2.length()){
      temp2=temp2.erase(found,temp2.length());
      temp1 = result.erase(0,found+1);
      if (desktop !=NULL){
        //std::cout<<"desktop: "<<desktop<<"\nresult: "<<temp2<<std::endl;
        if (temp2.compare(desktop)==0){return true;}
      }
      if (desktop_session !=NULL){
       // std::cout<<"desktop session: "<<desktop_session<<"\nresult: "<<temp2<<std::endl;
        if(temp2.compare(desktop_session)==0){return true;}
      }
      if (temp2.compare("unity")==0){return true;}
      temp2=temp1;
     }
     else{
       
     }
  }
  return false;
}

void Desktop::OnlyShowIn(const char* DE) {
  if(DE==NULL){return;}
  if(!isEmpty(notshowin)){
    std::string ONLY = notshowin->value();
    unsigned int finder = 0;
    finder=ONLY.find(DE);
    if(finder<ONLY.length()){
      make_red(onlyshowin);
      make_red(notshowin);
      return;
    }
  }
  onlyshowin->value(DE);
  onlyshowin->redraw();
}

void Desktop::open_file() {
  std::string message=gettext("Choose a Desktop File");
  std::string pat="*.desktop";
  const char* filer = Filename->value();
  std::string fname="desktop-file-editor.desktop";
  if(filer!=NULL){fname=filer;}
  std::string result =nativeFileDialog(message,fname,pat);
  load(result);
}

void Desktop::populate(std::string fileName) {
  //if(!linuxcommon::test_file(fileName)){return;}
  if(fileName.compare("")==0){return;}
  std::string filename=fileName; 
  std::string NAME,EXEC,CATS,TYPE,ICON,COMMENT,ONLY,NOT,URL,WMCLASS,KEYWORDS,IMPLEMENTS,VERSION,ENCODING,PATH,MIME,TRY,GENERIC,NODISPLAY,TERMINAL,STARTUPNOTIFY,HIDDEN,DBUS;
  
  TYPE=get_line(filename,"Type=");
  VERSION=get_line(filename,"Version=");
  NAME=name_line(filename);
  GENERIC=get_line(filename,"GenericName=");
  
  COMMENT=get_line(filename,"Comment=");
  ICON=get_line(filename,"Icon=");
  if(ICON.compare("")!=0){
    icon_display->copy_label("");
    makeWidgetIcon(ICON,icon_display,48);
  }
  ONLY=get_line(filename,"OnlyShowIn=");
  NOT=get_line(filename,"NotShowIn=");
  TRY=get_line(filename,"TryExec=");
  EXEC=get_line(filename,"Exec=");
  PATH=get_line(filename,"Path=");
  //Actions....
  MIME=get_line(filename,"MimeType");
  CATS=get_line(filename,"Categories=");
  IMPLEMENTS=get_line(filename,"Implements=");
  KEYWORDS=get_line(filename,"Keywords=");
  WMCLASS=get_line(filename,"StartupWMClass=");
  URL=get_line(filename,"URL=");
  MIME=get_line(filename,"MimeType");
  STARTUPNOTIFY=get_line(filename,"StatupNotify=");
  TERMINAL=get_line(filename,"Terminal=");
  NODISPLAY=get_line(filename,"NoDisplay=");
  DBUS=get_line(filename,"DBusActivatable=");
  HIDDEN=get_line(filename,"Hidden=");
  //extras
  ENCODING=get_line(filename,"Encoding=");
  //Setup
  set_input(name,NAME);
  set_input(genericname,GENERIC);
  set_input(exec,EXEC);
  set_input(comment,COMMENT);
  set_input(icon,ICON);
  set_input(tryexec,TRY);
  set_input(categories,CATS);
  set_input(onlyshowin,ONLY);
  set_input(type,TYPE);
  set_input(version,VERSION);
  set_input(path,PATH);
  set_input(implements,IMPLEMENTS);
  set_input(keywords,KEYWORDS);
  set_input(wmclass,WMCLASS);
  set_input(url,URL);
  set_input(mime,MIME);
  set_input(notify,STARTUPNOTIFY);
  set_input(nodisplay,NODISPLAY);
  set_input(terminal,TERMINAL);
  set_input(hidden,HIDDEN);
  set_input(dbus,DBUS);
  check_type();
}

bool Desktop::check_file() {
  std::string testFilename;
  if (isEmpty(Filename)){
    make_red(Filename);
    return false;
  }
  const char* filer = Filename->value();
  testFilename=filer;
  unsigned int found = 0;
  found=testFilename.find(".desktop");
  if (found > testFilename.length()){
    make_red(Filename);
    testFilename += ".desktop";
    Filename->value(testFilename.c_str());
    Filename->redraw();
    
  }
  found = 0;
  found= testFilename.find("/");
  if(found>testFilename.length()){
    std::string choice=choose_directory();
    if(choice.compare("")==0){
      make_red(Filename);
      return false;
    }
    choice+="/";
    choice+=testFilename;
    testFilename=choice;
  }
  Filename->value(testFilename.c_str());
  Filename->redraw();
  return true;
}

void Desktop::set_input(Fl_Input *o, std::string val) {
  make_white(o);
  o->value(val.c_str());
  o->redraw();
}

void Desktop::show_all() {
  activate(tryexec);
  activate(exec);
  activate(path);
  activate(terminal);
  activate(actions);
  activate(categories);
  activate(keywords);
  activate(notify);
  activate(wmclass);
  activate(mime);
  activate(url);
  activate(cat_Button);
  activate(notify_Button);
  activate(term_Button);
}

void Desktop::show_apps_only() {
  activate(tryexec);
  activate(exec);
  activate(path);
  activate(terminal);
  activate(actions);
  activate(categories);
  activate(keywords);
  activate(notify);
  activate(wmclass);
  activate(mime);
  activate(cat_Button);
  activate(notify_Button);
  activate(term_Button);
  DEactivate(url);
}

void Desktop::show_dir_only() {
  DEactivate(tryexec);
  DEactivate(exec);
  DEactivate(path);
  DEactivate(terminal);
  DEactivate(term_Button);
  DEactivate(actions);
  DEactivate(categories);
  DEactivate(cat_Button);
  DEactivate(keywords);
  DEactivate(notify);
  DEactivate(notify_Button);
  DEactivate(wmclass);
  DEactivate(mime);
  DEactivate(url);
}

void Desktop::show_link_only() {
  DEactivate(tryexec);
  DEactivate(exec);
  DEactivate(path);
  DEactivate(terminal);
  DEactivate(term_Button);
  DEactivate(actions);
  DEactivate(categories);
  DEactivate(cat_Button);
  DEactivate(keywords);
  DEactivate(notify);
  DEactivate(notify_Button);
  DEactivate(wmclass);
  DEactivate(mime);
  activate(url);
}

std::string Desktop::stringfile() {
  const char* FILENAME=Filename->value();
  if(FILENAME==NULL){std::cerr<<"Filename is NULL"<<std::endl;}
  if(isEmpty(Filename)){
    make_red(Filename);
    return "";
  }
  else{make_white(Filename);}
  const char* NAME = name->value();
  if(NAME==NULL){std::cerr<<"Name is NULL"<<std::endl;}
  if(isEmpty(name)){
    make_red(name);
    return "";
  }
  else{make_white(name);}
  const char* TYPE = type->value();
  if(TYPE==NULL){std::cerr<<"Type is NULL"<<std::endl;}
  if (isEmpty(type)){
    make_red(type);
    return "";
  }
  else{make_white(type);}
  std::string TypeOf=type->value(); 
  std::string fileContents="[Desktop Entry]\n";
  fileContents+=testValue("Type=",type);
  fileContents+=testValue("Version=",version);
  fileContents+=testValue("Name=",name);
  fileContents+=locales_string();
  fileContents+=testValue("GenericName=",genericname);
  if (TypeOf.compare("Application")==0){
    const char* EXEC = exec->value();
    if(EXEC==NULL){std::cerr<<"Executable is NULL"<<std::endl;}
    if (isEmpty(exec)){
      make_red(exec);
      return "";
    }
    fileContents+=testValue("Exec=",exec);
    fileContents+=testValue("TryExec=",tryexec);
    fileContents+=testValue("Terminal=", terminal);
    fileContents+=testValue("Categories=",categories);
    fileContents+=testValue("Path=",path);
    fileContents+=testValue("MimeType=",mime);
    fileContents+=testValue("Keywords=",keywords);
    fileContents+=testValue("StartUpWMClass=",wmclass);
    fileContents+=testValue("StartupNotify=",notify);
  }
  fileContents+=testValue("Comment=",comment);
  fileContents+=testValue("Icon=",icon);
  fileContents+=testValue("NoDisplay=",nodisplay);
  fileContents+=testValue("Hidden=", hidden);
  fileContents+=testValue("DBusActivatable=",dbus);
  fileContents+=testValue("Implements=",implements);
  
  //TODO test OnlyShowIn and NotShowIn to not have the same values ever
  fileContents+=testValue("NotShowIn=",notshowin);
  fileContents+=testValue("OnlyShowIn=",onlyshowin);
  
  if (TypeOf.compare("Link")==0){
    std::string linktext=testValue("URL=",url);
    if(linktext.compare("")==0){
      make_red(url);
      return "";
    }
    fileContents+=linktext;
  }
    
  return fileContents;
}

std::string Desktop::termie_out(std::string terminal_Command_You_Want_Output_From) {
  return linuxcommon::term_out(terminal_Command_You_Want_Output_From);
}

std::string Desktop::testValue(std::string TEXT, Fl_Input* o) {
  std::string fileContents;
  const char* tempval=o->value();
  if (tempval==NULL){return "";}
  std::string TEMPval=o->value();
  if(TEMPval.compare("")==0){return "";}
  fileContents+=TEXT;
  fileContents+=TEMPval;
  fileContents+="\n";
  return fileContents;
}

void Desktop::write_out() {
  const char* FILENAME=Filename->value();
  std::string fileContents=stringfile();
  if(!linuxcommon::save_string_to_file(fileContents,FILENAME)){
    error_win->show();
    linuxcommon::echo_error("Did not save the file correctly");
  }
}

void Desktop::save_file() {
  if(check_file()){
    std::string fileContents=stringfile();
    preview_window(fileContents)->show();
  }
}

Fl_Double_Window* Desktop::save_error() {
  { error_win = new Fl_Double_Window(270, 90, gettext("Save Error"));
    error_win->user_data((void*)(this));
    { Fl_Output* o = new Fl_Output(5, 25, 255, 25, gettext("There was an error saving the file:"));
      o->tooltip(gettext("Make sure you have permission to save."));
      o->box(FL_FLAT_BOX);
      o->align(Fl_Align(FL_ALIGN_TOP));
      o->value(Filename->value());
    } // Fl_Output* o
    { Fl_Button* o = new Fl_Button(195, 55, 60, 25, gettext("OK"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)62);
      o->selection_color(FL_DARK_GREEN);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_OK);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(130, 55, 40, 25, gettext("?"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)219);
      o->selection_color((Fl_Color)176);
      o->labelfont(1);
      o->labelsize(17);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_1);
    } // Fl_Button* o
    error_win->end();
  } // Fl_Double_Window* error_win
  return error_win;
}

Fl_Double_Window* Desktop::help_window() {
  { help_win = new Fl_Double_Window(280, 280, gettext("Help"));
    help_win->user_data((void*)(this));
    { Fl_Button* o = new Fl_Button(210, 245, 60, 25, gettext("CLOSE"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->selection_color((Fl_Color)64);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_CLOSE1);
    } // Fl_Button* o
    { help_browser = new Fl_Browser(15, 5, 255, 230);
      help_browser->box(FL_FLAT_BOX);
    } // Fl_Browser* help_browser
    help_win->end();
  } // Fl_Double_Window* help_win
  return help_win;
}

void Desktop::get_help(Fl_Browser *o) {
  const char* lang=getenv("LANG");
  if(lang==NULL)lang=getenv("LANGUAGE");
  else{
    std::string tmp=lang;
    unsigned int finder=tmp.find('.');
    if(finder<tmp.length()){tmp=tmp.erase(finder,std::string::npos);}
    lang=tmp.c_str();
  }
  if(lang==NULL)lang="en_US";
  std::string helpfile="/jwm-settings-manager/help-desktop-file-editor-";
  helpfile+=lang;
  std::string fullfile=linuxcommon::test_file_in_vector_path(helpfile,linuxcommon::desktop_dirs());
  if(linuxcommon::test_file(fullfile)){
    populateBrowserWithTextFile(o,fullfile);
  }
  else{
    fullfile="If you have trouble saving your file, ensure that you are able to save in the directory.  You may need to reopen the program as administrator by running:\n\npkexec desktop-file-editor";
    populateBrowserWithString(o,fullfile);
  }
}

void Desktop::populate_locales(Fl_Browser *o,std::string filename) {
  std::vector<std::string> STRING_VEC=linuxcommon::delimiter_vector_from_string(LOCALE_STRING,"\n");
  for( std::vector<std::string>::iterator it = STRING_VEC.begin();
   it!=STRING_VEC.end();
   ++it){
    std::string tmp=*it;  
    std::string res=no_browser_name_locale(filename,tmp);
    o->add(res.c_str());
  }
  o->redraw();
}

std::string Desktop::locales_string() {
  std::string result;
  for(int i=1;i<=result_locale->size();i++){
    std::string LINE="Name[";
    std::string thisLine; 
      std::string thisLocale;
    const char* tmpr=result_locale->text(i);
    if(tmpr!=NULL){
      const char* ltemp=locales_browser->text(i);
      if(ltemp!=NULL){
        thisLocale=ltemp;
        std::string tmp=tmpr;
        if(tmp.compare("")!=0){
          thisLine=LINE+thisLocale+"]="+tmp;
          errorOUT(thisLine);
          result=result+"\n"+thisLine;
        }
      }
    }
  }
  return result;
}

void Desktop::preview_text(Fl_Text_Display *o,std::string TEXT) {
  if(TEXT.compare("")==0)return;
  int tmp=TEXT.length();
  Fl_Text_Buffer *buf=new Fl_Text_Buffer(tmp);
  buf->text(TEXT.c_str());
  o->buffer(buf);
}

void Desktop::write_out(const char* txt) {
  const char* FILENAME=Filename->value();
  if(txt==NULL)return;
  if(FILENAME==NULL)return;
  std::string fileContents=txt;
  if(!linuxcommon::save_string_to_file(fileContents,FILENAME)){
    error_win->show();
    linuxcommon::echo_error("Did not save the file correctly");
  }
}

void Desktop::check_save() {
  const char* res=Filename->value();
  std::string result;
  if(res!=NULL){result=res;}
  std::string tmpRES=linuxcommon::translate_home(result);
  if(tmpRES.compare(result)!=0){
    Filename->value(tmpRES.c_str());
  }
  if(!linuxcommon::file_is_writable(result)){
    save_button->deactivate();
    unsigned int color=linuxcommon::get_fl_color("#006900");
    save_button->color(color);
  }
  else{
    unsigned int color=linuxcommon::get_fl_color("#00b600");
    save_button->color(color);  
    save_button->activate();
    
  }
  save_button->redraw();
}

int main(int argc, char *argv[]) {
  std::string command;
  try{
    //integers for searching the argv
    if(argc>0){
      for(int i=1;i<argc;++i){
        command=argv[i];
        for(int i=0;i<argc;i++){
          std::string tmp=linuxcommon::process_filename(command);
          if(tmp.compare("")!=0)command=tmp;
          if(linuxcommon::test_file(command)){
            Desktop D;
            std::cout<<"Command argument:"<<command<<std::endl;
            D.make_window(command)->show();
            return Fl::run();
          }
        }
      }
    }
    Desktop D;
    D.make_window("")->show();
    return Fl::run();
  }
  catch (const std::exception& e){
    std::cerr << "Unhandled exception:\n" << e.what() << std::endl;
    return EXIT_FAILURE;
  }
  catch (...){
    std::cerr << "Unknown exception!" << std::endl;
    return EXIT_FAILURE;
  }
}
