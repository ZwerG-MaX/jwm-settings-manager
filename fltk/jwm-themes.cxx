/*                 Joe's Window Manager Configuration
 *
 * This program configures JWM using tinyxml2 and FLTK
 *
 *         Copyright (C) 2014  Israel <israel@torios.org>
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * This has been developed as a part of the ToriOS Project
 * This has been developed by Israel<israel@torios.org>
 *
 *
 * You may redistribute this, but you must keep this comment in place
 * Jesus is my Lord, and if you don't like it feel free to ignore it.
 */
// generated by Fast Light User Interface Designer (fluid) version 1.0302

#include <libintl.h>
#include "jwm-themes.h"

void ThemesUI::cb_ok_i(Fl_Button*, void*) {
  const char* result = current_theme->label();
if(result!=NULL){
  change_theme(result,false);
};
}
void ThemesUI::cb_ok(Fl_Button* o, void* v) {
  ((ThemesUI*)(o->parent()->parent()->user_data()))->cb_ok_i(o,v);
}

void ThemesUI::cb_sys_theme_i(Fl_Browser* o, void*) {
  theme_cb(o, true);
}
void ThemesUI::cb_sys_theme(Fl_Browser* o, void* v) {
  ((ThemesUI*)(o->parent()->parent()->user_data()))->cb_sys_theme_i(o,v);
}

void ThemesUI::cb_save_button_i(Fl_Button*, void*) {
  save_theme();
}
void ThemesUI::cb_save_button(Fl_Button* o, void* v) {
  ((ThemesUI*)(o->parent()->parent()->user_data()))->cb_save_button_i(o,v);
}

void ThemesUI::cb_cancel_i(Fl_Button*, void*) {
  themes_window->hide();
UI ux;
ux.showSettings();
}
void ThemesUI::cb_cancel(Fl_Button* o, void* v) {
  ((ThemesUI*)(o->parent()->parent()->user_data()))->cb_cancel_i(o,v);
}

void ThemesUI::cb_usr_theme_i(Fl_Browser* o, void*) {
  theme_cb(o, false);
}
void ThemesUI::cb_usr_theme(Fl_Browser* o, void* v) {
  ((ThemesUI*)(o->parent()->parent()->user_data()))->cb_usr_theme_i(o,v);
}

void ThemesUI::cb_overwritten_i(Fl_Button*, void*) {
  const char* result = current_theme->label();
change_theme(result,true);
}
void ThemesUI::cb_overwritten(Fl_Button* o, void* v) {
  ((ThemesUI*)(o->parent()->parent()->user_data()))->cb_overwritten_i(o,v);
}

Fl_Double_Window* ThemesUI::make_window() {
  { Fl_Double_Window* o = themes_window = new Fl_Double_Window(610, 345, gettext("Themes"));
    themes_window->color((Fl_Color)31);
    themes_window->labelcolor(FL_BACKGROUND2_COLOR);
    themes_window->user_data((void*)(this));
    { Fl_Scroll* o = new Fl_Scroll(0, 0, 845, 660);
      o->color((Fl_Color)31);
      { ok = new Fl_Button(400, 210, 185, 30, gettext("Change Colors ONLY"));
        ok->tooltip(gettext("This will copy your current theme somewhere else"));
        ok->box(FL_FLAT_BOX);
        ok->color((Fl_Color)61);
        ok->selection_color((Fl_Color)58);
        ok->labelcolor(FL_BACKGROUND2_COLOR);
        ok->callback((Fl_Callback*)cb_ok);
      } // Fl_Button* ok
      { Fl_Browser* o = sys_theme = new Fl_Browser(10, 30, 130, 105, gettext("Themes"));
        sys_theme->type(2);
        sys_theme->box(FL_FLAT_BOX);
        sys_theme->selection_color(FL_DARK_RED);
        sys_theme->callback((Fl_Callback*)cb_sys_theme);
        sys_theme->align(Fl_Align(FL_ALIGN_TOP));
        flThemes theme;
        theme.populateThemes(o);
      } // Fl_Browser* sys_theme
      { tray = new Fl_Box(280, 30, 305, 40, gettext("Panel"));
        tray->box(FL_FLAT_BOX);
      } // Fl_Box* tray
      { button = new Fl_Box(205, 30, 75, 40, gettext("Button"));
        button->box(FL_FLAT_BOX);
      } // Fl_Box* button
      { awin = new Fl_Box(160, 100, 425, 40);
        awin->box(FL_FLAT_BOX);
      } // Fl_Box* awin
      { awin2 = new Fl_Box(160, 110, 425, 30);
        awin2->box(FL_FLAT_BOX);
      } // Fl_Box* awin2
      { awin_text = new Fl_Box(160, 100, 425, 40, gettext("Window (Active)"));
      } // Fl_Box* awin_text
      { iwin = new Fl_Box(160, 155, 425, 40);
        iwin->box(FL_FLAT_BOX);
      } // Fl_Box* iwin
      { iwin2 = new Fl_Box(160, 165, 425, 30);
        iwin2->box(FL_FLAT_BOX);
      } // Fl_Box* iwin2
      { iwin_text = new Fl_Box(160, 155, 425, 40, gettext("Window (Inactive)"));
      } // Fl_Box* iwin_text
      { save_button = new Fl_Button(170, 210, 160, 30, gettext("Save Custom Theme"));
        save_button->tooltip(gettext("This will copy your current theme somewhere else"));
        save_button->box(FL_FLAT_BOX);
        save_button->color((Fl_Color)94);
        save_button->callback((Fl_Callback*)cb_save_button);
      } // Fl_Button* save_button
      { cancel = new Fl_Button(215, 255, 65, 30, gettext("Cancel"));
        cancel->tooltip(gettext("This will copy your current theme somewhere else"));
        cancel->box(FL_FLAT_BOX);
        cancel->color((Fl_Color)80);
        cancel->selection_color((Fl_Color)64);
        cancel->labelcolor(FL_BACKGROUND2_COLOR);
        cancel->callback((Fl_Callback*)cb_cancel);
      } // Fl_Button* cancel
      { Fl_Browser* o = usr_theme = new Fl_Browser(10, 155, 130, 140, gettext("User Themes"));
        usr_theme->type(2);
        usr_theme->box(FL_FLAT_BOX);
        usr_theme->selection_color(FL_DARK_RED);
        usr_theme->callback((Fl_Callback*)cb_usr_theme);
        usr_theme->align(Fl_Align(FL_ALIGN_TOP));
        flThemes theme;
        theme.populateUserThemes(o);
      } // Fl_Browser* usr_theme
      { button_icon = new Fl_Box(160, 30, 45, 40);
        button_icon->box(FL_FLAT_BOX);
      } // Fl_Box* button_icon
      { overwritten = new Fl_Button(400, 250, 190, 35, gettext("Overwrite Current Theme"));
        overwritten->tooltip(gettext("This will copy your current theme somewhere else"));
        overwritten->box(FL_FLAT_BOX);
        overwritten->color((Fl_Color)61);
        overwritten->selection_color((Fl_Color)58);
        overwritten->labelcolor(FL_BACKGROUND2_COLOR);
        overwritten->callback((Fl_Callback*)cb_overwritten);
      } // Fl_Button* overwritten
      o->end();
    } // Fl_Scroll* o
    { current_theme = new Fl_Box(25, 305, 570, 30);
      current_theme->box(FL_FLAT_BOX);
      current_theme->color((Fl_Color)55);
    } // Fl_Box* current_theme
    { amin = new Fl_Box(490, 105, 30, 30);
    } // Fl_Box* amin
    { amax = new Fl_Box(520, 105, 30, 30);
    } // Fl_Box* amax
    { aclose = new Fl_Box(550, 105, 30, 30);
    } // Fl_Box* aclose
    { imin = new Fl_Box(485, 160, 30, 30);
    } // Fl_Box* imin
    { imax = new Fl_Box(515, 160, 30, 30);
    } // Fl_Box* imax
    { iclose = new Fl_Box(545, 160, 30, 30);
    } // Fl_Box* iclose
    Config config;config.under_mouse(o);
    o->icon(config.Get_Fl_Icon(jsm_theme_xpm));
    themes_window->xclass("jsm-theme");
    themes_window->end();
  } // Fl_Double_Window* themes_window
  return themes_window;
}

void ThemesUI::change_theme(const char* whichTheme, bool overwrite) {
  flThemes theme;
  if (overwrite){theme.copier(whichTheme);}
  else if (!overwrite){theme.modCurrentTheme(button,button_icon,tray,awin,awin2,awin_text,iwin,iwin2,iwin_text,whichTheme);}
  theme.saveJWMRC(themes_window);
  UI ux;
  ux.showSettings();
}

void ThemesUI::save_theme() {
  flThemes theme;
  std::string save_name = choose_directory(gettext("Save File"));
  if (save_name.compare("")==0){return;}
  const char* save_file = save_name.c_str();
  int result = theme.saveAs(save_file);
  if(result!=0){fl_alert("Problem saving: %s",save_file); return;}
  theme.populateUserThemes(usr_theme);
}

std::string ThemesUI::choose_directory(const char* whichChoice) {
  std::string result="";
  std::string label = gettext("Choose ");
  label += whichChoice;
  const char * message = label.c_str();
  flThemes themie;
  const char* directory_path = (themie.userThemeDir()).c_str();
  Fl_Native_File_Chooser fnfc;
  fnfc.title(message);
  fnfc.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);
  fnfc.directory(directory_path); // default directory to use
  int choice =0;
  // Show native chooser
  switch ( fnfc.show() ){
    case -1:
  //     printf("ERROR: %s\n", fnfc.errmsg());
       break; // ERROR
    case 1:
  //    printf("CANCEL\n");
      break; // CANCEL
    default:
      result = fnfc.filename();
      /*
      std::string message = gettext("Save as ");
      message +=result;
      const char* yes = gettext("Yes");
      const char* no = gettext("No");
      const char* q = gettext("Cancel");
      */
      choice = fl_choice("Save","No","Yes","Cancel");
      if (choice==1){
        break;
      }
      break; // FILE CHOSEN
  }
  return result;
}

std::string ThemesUI::choose_file() {
  std::string result="";
  std::string label = gettext("Choose a file");
  const char * message = label.c_str();
  flThemes themie;
  const char* directory_path = (themie.userThemeDir()).c_str();
  Fl_Native_File_Chooser fnfc;
  fnfc.title(message);
  fnfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
  fnfc.directory(directory_path); // default directory to use
  // Show native chooser
  switch ( fnfc.show() ){
    case -1:
  //     printf("ERROR: %s\n", fnfc.errmsg());
       break; // ERROR
    case 1:
  //    printf("CANCEL\n");
      break; // CANCEL
    default:
      result = fnfc.filename();
      break; // FILE SAVE NAME
  }
  return result;
}

void ThemesUI::theme_cb(Fl_Browser* browser,bool systemTheme) {
  int line = browser->value();
  std::string text = browser->text(line);
  std::string path ="";
  flThemes theme;
  if(systemTheme){
  path = theme.sysThemeDir();
  path= path + text+"/";
  }
  else{path = theme.userThemeDir();}
  if(path.compare("")==0){return;}
  path+=text;
  //std::cout<<"filename: "<<path<<std::endl;
  current_theme->copy_label(path.c_str());
  theme.updateTheme(button,button_icon,tray,awin,awin2,awin_text,iwin,iwin2,iwin_text,amin,amax,aclose,imin,imax,iclose,path);
}
